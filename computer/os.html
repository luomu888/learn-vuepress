<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第一章 导论 | luomu</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="luomu">
    
    <link rel="preload" href="/learn-vuepress/assets/css/0.styles.216a5ded.css" as="style"><link rel="preload" href="/learn-vuepress/assets/js/app.58b32b08.js" as="script"><link rel="preload" href="/learn-vuepress/assets/js/6.0c5ddd61.js" as="script"><link rel="preload" href="/learn-vuepress/assets/js/1.a3f35cab.js" as="script"><link rel="preload" href="/learn-vuepress/assets/js/4.c6620eae.js" as="script"><link rel="prefetch" href="/learn-vuepress/assets/js/10.e64b2106.js"><link rel="prefetch" href="/learn-vuepress/assets/js/11.acfcb00e.js"><link rel="prefetch" href="/learn-vuepress/assets/js/12.6cdca1ad.js"><link rel="prefetch" href="/learn-vuepress/assets/js/13.ed4c5228.js"><link rel="prefetch" href="/learn-vuepress/assets/js/14.dc698bff.js"><link rel="prefetch" href="/learn-vuepress/assets/js/15.cf43ae37.js"><link rel="prefetch" href="/learn-vuepress/assets/js/16.25aa33c8.js"><link rel="prefetch" href="/learn-vuepress/assets/js/17.de597ac3.js"><link rel="prefetch" href="/learn-vuepress/assets/js/18.d48faa61.js"><link rel="prefetch" href="/learn-vuepress/assets/js/3.9a301622.js"><link rel="prefetch" href="/learn-vuepress/assets/js/5.17c94edb.js"><link rel="prefetch" href="/learn-vuepress/assets/js/7.1339d2bf.js"><link rel="prefetch" href="/learn-vuepress/assets/js/8.847a5e69.js"><link rel="prefetch" href="/learn-vuepress/assets/js/9.fb445241.js">
    <link rel="stylesheet" href="/learn-vuepress/assets/css/0.styles.216a5ded.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-130b300a><div data-v-130b300a><div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-130b300a data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>luomu</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>luomu</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-130b300a><header class="navbar" data-v-130b300a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">luomu</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/learn-vuepress/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      luomu的 Java 博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/luomu888" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-130b300a></div> <aside class="sidebar" data-v-130b300a><div class="personal-info-wrapper" data-v-39576ba9 data-v-130b300a><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>8</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="/learn-vuepress/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      luomu的 Java 博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/luomu888" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机底层</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-vuepress/computer/design.html" class="sidebar-link">设计模式</a></li><li><a href="/learn-vuepress/computer/jiwang.html" class="sidebar-link">计算机网络</a></li><li><a href="/learn-vuepress/computer/Linux.html" class="sidebar-link">Linux</a></li><li><a href="/learn-vuepress/computer/os.html" aria-current="page" class="active sidebar-link">操作系统</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面经</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python学习笔记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-130b300a><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-130b300a><main class="page"><section><div class="page-title"><h1 class="title">第一章 导论</h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="第一章-导论"><a href="#第一章-导论" class="header-anchor">#</a> 第一章 导论</h1> <p>本章目标</p> <p>1、描述==计算机系统的基本组成==</p> <p>2、概述<strong>计算机系统的主要组件</strong></p> <p>3、概述<strong>多种类型的计算机环境</strong></p> <p>4、探讨<strong>多个开源的操作系统</strong></p> <hr> <p>操作系统位于==计算机用户与计算机硬件之间，中介==</p> <p>作用：</p> <p>1、提供环境，以便用户执行程序</p> <p>2、<font color="red">管理计算机硬件的程序</font></p> <p>3、大型机主要优化<font color="red">硬件使用率</font></p> <h2 id="操作系统的功能"><a href="#操作系统的功能" class="header-anchor">#</a> 操作系统的功能</h2> <p>计算机系统分为4个组件：==硬件、操作系统、应用程序、用户==（底层到顶层）</p> <p>硬件：<strong>CPU中央处理单元、内存、输入/输出设备</strong>，为系统提供基本的计算机资源，<font color="purple">操作系统控制硬件</font>，并协调各个用户应用程序的硬件使用</p> <p><font color="orange">操作系统类似政府</font>，本身不能实现任何有用的功能，而<font color="green">提供一个方便程序执行的环境</font></p> <h3 id="操作系统的定义"><a href="#操作系统的定义" class="header-anchor">#</a> 操作系统的定义</h3> <p>操作系统：==控制和分配I/O==（input、output输入输出设备）==设备资源的共同功能==被组成一个<font color="red">软件</font>模块</p> <p>公认的定义：==内核==</p> <h2 id="计算机系统的组成"><a href="#计算机系统的组成" class="header-anchor">#</a> 计算机系统的组成</h2> <p>通过<font color="red">总线</font>相连接</p> <p><img src="/learn-vuepress/assets/img/image-20210919173306318.8c4c52f4.png" alt="image-20210919173306318"></p> <h3 id="计算机系统的运行"><a href="#计算机系统的运行" class="header-anchor">#</a> 计算机系统的运行</h3> <p>计算机系统包括==一个或多个CPU和若干设备控制器，通过总线连接，总线提供共享内存的访问==</p> <p><font color="red">CPU与设备控制器可以并发执行</font>，竞争访问内存，此时需要<font color="purple">内存控制器</font>来协调</p> <p>==引导程序（只读内存ROM）==：开机时，初始操作系统，<font color="green">位于操作系统内核并加载到内存</font>，一旦内核加载到内存并执行，就开始为系统和用户提供服务</p> <p><font color="purple">事件发生</font>：硬件（总线发送到CPU）和软件（系统调用）的中断来通知</p> <h3 id="存储结构"><a href="#存储结构" class="header-anchor">#</a> 存储结构</h3> <p><img src="/learn-vuepress/assets/img/image-20210919184751935.958a33ce.png" alt="image-20210919184751935"></p> <p>内存：随机访问内存（RAM），动态随机访问内存DRAM</p> <h3 id="i-o结构"><a href="#i-o结构" class="header-anchor">#</a> I/O结构</h3> <p>操作系统为每个设备控制器提供一个==设备驱动程序==</p> <img src="/learn-vuepress/assets/img/image-20210919184838712.48383438.png" alt="image-20210919184838712"> <h2 id="计算机系统的体系结构"><a href="#计算机系统的体系结构" class="header-anchor">#</a> 计算机系统的体系结构</h2> <h3 id="单处理器系统"><a href="#单处理器系统" class="header-anchor">#</a> 单处理器系统</h3> <p>只有一个CPU</p> <p>==通用指令集==：可以执行用户进程，执行很大东西</p> <p>==专用处理器==：特定设备的处理器，如磁盘、键盘、图形处理器（显示器）</p> <h3 id="多处理器系统"><a href="#多处理器系统" class="header-anchor">#</a> 多处理器系统</h3> <p>多CPU，也称<font color="red">多核</font></p> <p>优点：</p> <p>1、增加<font color="red">吞吐量</font></p> <p>2、规模经济</p> <p>3、增加可靠性（一个CPU坏不影响其他）</p> <p><img src="/learn-vuepress/assets/img/image-20210919195652501.4ec98c75.png" alt="image-20210919195652501"></p> <p>非对称处理器：有各自特定的任务，==主从关系==，==主处理器==调度==从处理器==，并安排任务</p> <p>对称处理器：没有主从关系</p> <h3 id="集群系统"><a href="#集群系统" class="header-anchor">#</a> 集群系统</h3> <p>将多个CPU组合，通过<font color="red">网络连接</font>，提供<font color="red">高可用性</font>的服务</p> <p><img src="/learn-vuepress/assets/img/image-20210919202020157.2fbc990e.png" alt="image-20210919202020157"></p> <h2 id="操作系统的结构"><a href="#操作系统的结构" class="header-anchor">#</a> 操作系统的结构</h2> <p>具有<font color="red">多道程序</font>能力，运行多个程序，多道程序安排作业，==使得CPU总有一个作业，提高CPU利用率==</p> <p>由于内存太小不能存所有作业，首先存在==磁盘的作业池==上，作业即进程</p> <p><img src="/learn-vuepress/assets/img/image-20210919204200261.459a61d3.png" alt="image-20210919204200261"></p> <p><font color="red">分时系统</font>：确保响应时间，提高一个小部分的==分时==计算机资源，即==CPU切换到其他进程的时间==，CPU只能执行一个进程</p> <h2 id="操作系统的执行"><a href="#操作系统的执行" class="header-anchor">#</a> 操作系统的执行</h2> <p>软件-------------------------操作系统------------------------硬件</p> <p>==操作系统==是==中断==驱动的，==事件==是中断或陷阱（或异常）引起的</p> <p>陷阱（或异常）：软件生成的中断，<font color="red">用户请求</font></p> <h3 id="双重模式与多重模式的执行"><a href="#双重模式与多重模式的执行" class="header-anchor">#</a> 双重模式与多重模式的执行</h3> <p>用户模式（1）和内核模式（0）：</p> <p>1、==硬件==通过==模式位==表示当前模式</p> <p>2、<font color="red">执行用户应用，用户模式，请求操作系统服务，内核模式</font></p> <p><img src="/learn-vuepress/assets/img/image-20210919211616166.ccd66395.png" alt="image-20210919211616166"></p> <p>双重模式==执行提供保护手段==，将可能引起==损害机器指令==作为<font color="red">特权指令</font>，在==内核模式下执行==，用户模式想执行硬件不理会</p> <h3 id="定时器"><a href="#定时器" class="header-anchor">#</a> 定时器</h3> <p>==操作系统维持控制CPU==，<font color="red">进程超过一定时间没响应</font>，则关闭，防止程序陷入死循环</p> <h2 id="进程管理"><a href="#进程管理" class="header-anchor">#</a> 进程管理</h2> <p>==执行中的程序称为进程==，程序计数器（PC），有下一个指令的相关信息</p> <p><font color="red">进程是系统的工作单元</font>，其中有操作系统进程，也有用户进程，所有进程<font color="red">并发执行</font></p> <p>操作系统负责进程管理的以下活动：</p> <p>1、<font color="red">在CPU上调度</font>进程和线程</p> <p>2、<font color="red">创建和销毁</font>用户进程和系统进程</p> <p>3、<font color="red">挂起和重启</font>进程</p> <p>4、提供进程<font color="red">同步</font>机制</p> <p>5、提供进程<font color="red">通信</font>机制</p> <h2 id="内存管理"><a href="#内存管理" class="header-anchor">#</a> 内存管理</h2> <p>如果==CPU执行指令==，那么这些数据首先通过==IO调度传到内存==，在内存中保留多个程序（多道程序）需要内存管理</p> <p>操作系统负责内存管理的以下活动：</p> <p>1、记录内存的<font color="red">哪部分被使用以及谁使用</font></p> <p>2、决定哪些进程会<font color="red">调入或调出</font>内存</p> <p>3、根据需要<font color="red">分配和释放</font>内存空间</p> <h2 id="存储管理"><a href="#存储管理" class="header-anchor">#</a> 存储管理</h2> <p>信息存储的==统一逻辑视图==</p> <p>文件：操作系统==映射==文件到==物理媒介==，并通过==存储设备来访问文件==</p> <h3 id="高速缓存"><a href="#高速缓存" class="header-anchor">#</a> 高速缓存</h3> <p><img src="/learn-vuepress/assets/img/image-20210919220923783.5ea17214.png" alt="image-20210919220923783"></p> <p><img src="/learn-vuepress/assets/img/image-20210919221301434.7d240af2.png" alt="image-20210919221301434"></p> <h3 id="i-o系统"><a href="#i-o系统" class="header-anchor">#</a> I/O系统</h3> <p>==IO子系统==为操作系统本身==隐藏IO设备的特性==，<font color="red">只有设备驱动程序才能知道</font></p> <p>IO子系统包括以下几个组件：</p> <p>1、<font color="green">缓冲、高速缓存和假脱机的内存管理组件</font></p> <p>2、<font color="green">设备驱动器的通用接口</font></p> <p>3、<font color="green">特定硬件设备的驱动程序</font></p> <h2 id="保护与安全"><a href="#保护与安全" class="header-anchor">#</a> 保护与安全</h2> <p>保护：控制进程或用户访问计算机系统的资源，例==阻止用户对内核的非法调用==</p> <p>安全：==防止系统受外部或内部攻击==</p> <h2 id="计算环境"><a href="#计算环境" class="header-anchor">#</a> 计算环境</h2> <p>操作系统如何用于各种计算环境</p> <h3 id="分布计算"><a href="#分布计算" class="header-anchor">#</a> 分布计算</h3> <p>分布式系统是==物理上分开的，通过网络相连==</p> <h3 id="客户机-服务器计算"><a href="#客户机-服务器计算" class="header-anchor">#</a> 客户机-服务器计算</h3> <p>client/server</p> <p><img src="/learn-vuepress/assets/img/image-20210920165829052.5c5d1dad.png" alt="image-20210920165829052"></p> <h3 id="对等计算"><a href="#对等计算" class="header-anchor">#</a> 对等计算</h3> <p>不区分客户机和服务器，每个节点都可以作为客户机或服务器</p> <p><img src="/learn-vuepress/assets/img/image-20210920170100313.ca90c6d1.png" alt="image-20210920170100313"></p> <h3 id="虚拟化"><a href="#虚拟化" class="header-anchor">#</a> 虚拟化</h3> <p><font color="red">操作系统</font>可以在<font color="red">其他操作系统上运行应用程序</font>，如VMware软件、阿里云服务器等</p> <p><img src="/learn-vuepress/assets/img/image-20210920170433227.7af198aa.png" alt="image-20210920170433227"></p> <h3 id="云计算"><a href="#云计算" class="header-anchor">#</a> 云计算</h3> <p>==虚拟化技术的延伸==，一个显示屏，没有CPU，<font color="red">显示屏只是为了显示，所有计算操作都在远程的云上</font></p> <p>云计算类型：</p> <p>1、公有云</p> <p>2、私有云</p> <p>3、混合云</p> <p>4、软件即服务（SaaS）</p> <p>5、平台即服务（PaaS）</p> <p>6、基础设施及服务（IaaS）</p> <p><img src="/learn-vuepress/assets/img/image-20210920170644021.2741656d.png" alt="image-20210920170644021"></p> <h3 id="实时嵌入式系统"><a href="#实时嵌入式系统" class="header-anchor">#</a> 实时嵌入式系统</h3> <p>==嵌入式系统几乎总是采用实时操作系统==，单一，例：汽车、家电；不像计算机的操作系统要符合大多数情况</p> <h3 id="开源操作系统"><a href="#开源操作系统" class="header-anchor">#</a> 开源操作系统</h3> <table><thead><tr><th style="text-align:center;">开放源代码</th> <th style="text-align:center;">闭源</th></tr></thead> <tbody><tr><td style="text-align:center;">Linux、Unix</td> <td style="text-align:center;">Windows</td></tr> <tr><td style="text-align:center;">Google的Android</td> <td style="text-align:center;">苹果的IOS</td></tr></tbody></table> <h1 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="header-anchor">#</a> 第二章 操作系统结构</h1> <p>本章目标</p> <p>1、描述操作系统为==用户、进程和其他系统==提供的服务</p> <p>2、讨论构建==操作系统的各种方式==</p> <p>3、解释如何==安装与定制操作系统==以及如何==启动操作系统==</p> <h2 id="操作系统的服务"><a href="#操作系统的服务" class="header-anchor">#</a> 操作系统的服务</h2> <p>1、==用户界面==：<font color="red">命令行、图形用户</font>、批处理界面</p> <p>2、==程序执行==：加载程序到内存</p> <p>3、通信：一个进程与另一个进程交换信息，例内存共享等</p> <p>4、错误检测：检测和更正错误</p> <p>5、==资源分配==：多个程序运行时，资源的分配</p> <p>6、记账：记录用户使用资源的类型和数量</p> <p><img src="/learn-vuepress/assets/img/image-20210920175536363.106782c9.png" alt="image-20210920175536363"></p> <h2 id="用户与操作系统的界面"><a href="#用户与操作系统的界面" class="header-anchor">#</a> 用户与操作系统的界面</h2> <p>主要：==命令==解释程序和==图形==用户界面</p> <h3 id="命令解释程序"><a href="#命令解释程序" class="header-anchor">#</a> 命令解释程序</h3> <p>==Shell（脚本）==：解释程序，<font color="red">命令转换为机器指令</font></p> <h3 id="图形用户界面"><a href="#图形用户界面" class="header-anchor">#</a> 图形用户界面</h3> <p>优点：操作简单				缺点：复杂度高，bug更多</p> <h2 id="系统调用"><a href="#系统调用" class="header-anchor">#</a> 系统调用</h2> <p>提供==操作系统服务接口==，通常开发人员根据==应用程序接口（API）==来设计程序</p> <p><img src="/learn-vuepress/assets/img/image-20210920182605130.6d0606fd.png" alt="image-20210920182605130"></p> <p>例：一个简单的复制文件，可能需要n次系统API的调用</p> <p><img src="/learn-vuepress/assets/img/image-20210920182351818.7a6142b6.png" alt="image-20210920182351818"></p> <h2 id="系统调用的类型"><a href="#系统调用的类型" class="header-anchor">#</a> 系统调用的类型</h2> <p>大致分为六类：</p> <p>1、进程控制</p> <p>2、文件管理</p> <p>3、设备管理</p> <p>4、信息维护</p> <p>5、通信</p> <p>6、保护</p> <p><img src="/learn-vuepress/assets/img/image-20210920190836313.be99760e.png" alt="image-20210920190836313"></p> <h3 id="进程控制"><a href="#进程控制" class="header-anchor">#</a> 进程控制</h3> <p>例：</p> <p><strong>异常</strong>停止当前执行的程序，那么可能转<strong>存储内存到磁盘</strong></p> <p><strong>多个进程共享数据，确保数据的完整性</strong>（即只能一个使用完，下一个才能用），使用==锁定（lock==），解锁之前其他不能访问</p> <p><img src="/learn-vuepress/assets/img/image-20210920191614585.930bdc88.png" alt="image-20210920191614585"></p> <h2 id="操作系统的结构-2"><a href="#操作系统的结构-2" class="header-anchor">#</a> 操作系统的结构</h2> <p>操作系统<strong>庞大且复杂</strong>，所以分成==子系统或模块==</p> <h3 id="分层方法"><a href="#分层方法" class="header-anchor">#</a> 分层方法</h3> <p>优点：==简化了构造和调试==，<strong>每层只能调用更底层的</strong>功能和服务</p> <p><img src="/learn-vuepress/assets/img/image-20210920200749163.82b898b6.png" alt="image-20210920200749163"></p> <h3 id="微内核"><a href="#微内核" class="header-anchor">#</a> 微内核</h3> <p>==对内核进行模块化==，删除所有不必要的部件，将他们当作<strong>系统级与用户级的程序来实现</strong>，使内核较小</p> <p>主要功能：为客户端程序和运行在用户空间的各种服务==提供通信==</p> <p>优点：内核更小、==便于扩展==、更好的安全性和可靠性、便于移植。</p> <p>缺点：==性能会受损==，即来回切换模式</p> <h3 id="模块"><a href="#模块" class="header-anchor">#</a> 模块</h3> <p>目前的操作系统采用==可加载的内核模块==，需要那个就加载到内核</p> <p><img src="/learn-vuepress/assets/img/image-20210920201511915.34fbd27d.png" alt="image-20210920201511915"></p> <h3 id="混合系统"><a href="#混合系统" class="header-anchor">#</a> 混合系统</h3> <p><img src="/learn-vuepress/assets/img/image-20210920201607622.855ce948.png" alt="image-20210920201607622"></p> <h2 id="系统引导"><a href="#系统引导" class="header-anchor">#</a> 系统引导</h2> <p>操作系统如何启动？</p> <p>系统引导：==加载内核==以启动计算机的过程</p> <p>大多数计算机系统有一小块代码为==引导程序（只读存储器ROM）==，它能<font color="red">定位内核</font>，并<font color="red">加载到内存以开始执行</font></p> <h1 id="第三章-进程"><a href="#第三章-进程" class="header-anchor">#</a> 第三章 进程</h1> <p>本章目标：</p> <p>1、引入<strong>进程概念</strong>，即执行的程序，这是所有计算的基础</p> <p>2、讨论进程的<strong>各类特性，包括调度、创建和终止</strong></p> <p>3、探讨通过<strong>共享内存和消息传递的进程间通信</strong></p> <p>4、讨论<strong>客户机与服务器系统间的通信</strong></p> <hr> <p>==进程是执行中的程序==，是现代分时操作系统的==工作单元==，通过<strong>CPU</strong>的<strong>多路复用</strong>，所有==进程==可以==并发执行==</p> <h2 id="进程概念"><a href="#进程概念" class="header-anchor">#</a> 进程概念</h2> <p>CPU活动：执行作业（job）、任务（task）、程序</p> <h3 id="进程"><a href="#进程" class="header-anchor">#</a> 进程</h3> <p><strong>程序本身不是进程</strong>，==程序是被动实体==，如可执行文件（.exe），而==进程是活动实体==，一个可执行文件被加载到内存时，这个程序就成为进程，<font color="red">进程里包含线程</font></p> <p>==进程是操作系统进行资源分配和调度的基本单位==，即工作单元</p> <p><img src="/learn-vuepress/assets/img/image-20210920205204834.02e80f34.png" alt="image-20210920205204834"></p> <h3 id="进程状态"><a href="#进程状态" class="header-anchor">#</a> 进程状态</h3> <p>每个进程可能处于以下状态：</p> <p>1、新的（new）：进程创建</p> <p>2、运行（running）：正在执行</p> <p>3、等待（waiting）：阻塞状态，进程等待发生某个事件（如IO完成），即<strong>某一时刻要打印，向等待IO设备的连接，连接成功后进入就绪，最后运行</strong></p> <p>4、就绪（ready）：进程等待分配处理器</p> <p>5、终止（terminated）：进程结束</p> <p><img src="/learn-vuepress/assets/img/image-20210920210415629.2149f04b.png" alt="image-20210920210415629"></p> <h3 id="进程控制块"><a href="#进程控制块" class="header-anchor">#</a> 进程控制块</h3> <p>每个进程采用<font color="red">进程控制块（PCB）</font>来表示，信息的仓库，==PCB底层是双向链表==</p> <p><img src="/learn-vuepress/assets/img/image-20210921170748503.a05b339c.png" alt="image-20210921170748503"></p> <p><font color="red">进程间的切换：实际是PCB之间的切换</font></p> <p><img src="/learn-vuepress/assets/img/image-20210921170952360.5eb23c28.png" alt="image-20210921170952360"></p> <h2 id="进程调度"><a href="#进程调度" class="header-anchor">#</a> 进程调度</h2> <p>1、多道程序：提高<font color="red">CPU利用率</font></p> <p>2、分时系统：快速<font color="red">切换CPU</font></p> <p>3、进程调度器：<font color="red">选择一个可用进程到CPU上执行</font></p> <h3 id="调度队列"><a href="#调度队列" class="header-anchor">#</a> 调度队列</h3> <p>就绪队列：==等待运行==的进程</p> <p>设备列表：==等待IO设备==的进程</p> <p><img src="/learn-vuepress/assets/img/image-20210921182459387.d1c18df0.png" alt="image-20210921182459387"></p> <h3 id="调度程序"><a href="#调度程序" class="header-anchor">#</a> 调度程序</h3> <p>操作系统通过调度程序来选择进程</p> <ul><li><strong>长</strong>期调度程序：放在<font color="red">缓冲池（磁盘）</font>中</li> <li><strong>中</strong>期：放在作业池中，进程可以<font color="red">换出，换入</font></li> <li><strong>短</strong>期：在等待状态</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210921182607681.90cd1c5c.png" alt="image-20210921182607681"></p> <ol><li>IO密集型进程：IO占用更多的时间</li> <li>CPU密集型进程：CPU计算占用更多时间</li></ol> <h3 id="上下文切换"><a href="#上下文切换" class="header-anchor">#</a> 上下文切换</h3> <ul><li>==中断：系统保存进程的上下文，以便处理后恢复==</li> <li>==进程上下文采用进程PCB表示==</li> <li>==切换的时间是纯粹的开销，CPU在此期间是空闲的==</li></ul> <h2 id="进程运行"><a href="#进程运行" class="header-anchor">#</a> 进程运行</h2> <p>大多数系统的==进程能够并发执行，动态创建和删除，==</p> <h3 id="进程创建"><a href="#进程创建" class="header-anchor">#</a> 进程创建</h3> <p>对进程识别采用<font color="red">唯一的进程标识符（pid）</font>，是一个整数值，通过<font color="red">pid可以访问内核中进程的各种属性</font></p> <p><strong>创建新进程时，两种执行可能：</strong></p> <ul><li>==父和子进程并发执行==</li> <li>==父进程等待==，直到子进程执行完成</li></ul> <p><strong>新进程的地址空间</strong>也有两种可能：</p> <ul><li>具有与父进程==同样的程序和数据==</li> <li>==加载另一个新程序==</li></ul> <h3 id="进程终止"><a href="#进程终止" class="header-anchor">#</a> 进程终止</h3> <p>进程终止时，操作系统会释放其资源</p> <p><strong>父进程终止子进程</strong>的原因：</p> <ol><li>子进程使用==超过它所分配的资源==</li> <li>分配给子进程的==任务不再需要==</li> <li>==父进程退出==，不允许子进程在无父进程时执行</li></ol> <p>==级联终止==：<font color="red">一个进程终止，所有其对应的子进程也终止</font>，对应诛杀九族</p> <h2 id="进程间通信"><a href="#进程间通信" class="header-anchor">#</a> 进程间通信</h2> <p>==并发执行进程==可以是==独立的也可以是协作的==</p> <p>允许协作的==理由==：</p> <ul><li><strong>信息共享</strong></li> <li><strong>计算加速</strong></li> <li><strong>模块化</strong></li></ul> <p>协作需要一种<font color="red">进程间通信机制</font>：两种基本模型（==内存共享和消息传递==）</p> <table><thead><tr><th style="text-align:center;">共享内存</th> <th style="text-align:center;">消息传递</th></tr></thead> <tbody><tr><td style="text-align:center;"><font color="red">建立共享内存区域</font></td> <td style="text-align:center;">直接通信：<font color="red">明确通信的接收者和发送者</font></td></tr> <tr><td style="text-align:center;">确保它们<strong>不向同一位置写入数据</strong></td> <td style="text-align:center;">间接通信<font color="red">：通过邮箱或端口来发送或接收</font></td></tr> <tr><td style="text-align:center;"><font color="red">生产者进程--缓冲区（存储共享数据）--消费者进程</font></td> <td style="text-align:center;">==阻塞和非阻塞（即消息和进程能不能同时）==</td></tr> <tr><td style="text-align:center;">无界缓冲区，缓冲区为空，消费者需要等待</td> <td style="text-align:center;">阻塞：发送进程阻塞，接收进程阻塞</td></tr> <tr><td style="text-align:center;">有界，<strong>缓冲区为空，消费者等待，缓冲区满了，生产者等待</strong></td> <td style="text-align:center;">非阻塞：发送进程发送消息，接收进程接收消息</td></tr></tbody></table> <p><img src="/learn-vuepress/assets/img/image-20210922194824359.ec978f9d.png" alt="image-20210922194824359"></p> <h2 id="客户机-服务器通信"><a href="#客户机-服务器通信" class="header-anchor">#</a> 客户机/服务器通信</h2> <ul><li>socket（套接字）</li> <li>远程过程调用RPC</li> <li>管道</li></ul> <h3 id="套接字"><a href="#套接字" class="header-anchor">#</a> 套接字</h3> <p>每个进程各有一个套接字，每个==socket由ip和端口组成==</p> <p><img src="/learn-vuepress/assets/img/image-20210922202343192.8544ae77.png" alt="image-20210922202343192"></p> <p>缺点：低级形式通信，<font color="red">只允许交换无结构的字节流，C/S需要加上数据结构</font></p> <h3 id="远程过程调用"><a href="#远程过程调用" class="header-anchor">#</a> 远程过程调用</h3> <p>==通过网络来通信==</p> <p><img src="/learn-vuepress/assets/img/image-20210922202614387.700868dd.png" alt="image-20210922202614387"></p> <h3 id="管道"><a href="#管道" class="header-anchor">#</a> 管道</h3> <p>实现管道，考虑四个问题：</p> <ol><li><font color="red">单向通信还是双向通信</font></li> <li>==双向通信时==，<font color="red">是半双工（数据在同一时间只能按一个方向传输）还是全双工</font>（两个方向都可以传输）</li> <li>通信进程之间<font color="red">是否有关系（父子）</font></li> <li><font color="red">是否通过网络</font>，还是在同一台机器上</li></ol> <table><thead><tr><th style="text-align:center;">普通管道</th> <th style="text-align:center;">命名管道</th></tr></thead> <tbody><tr><td style="text-align:center;">生产者-消费者</td> <td style="text-align:center;">多个进程都可以用它</td></tr> <tr><td style="text-align:center;">==通信时才存在==</td> <td style="text-align:center;">==通信结束后继续存在==</td></tr></tbody></table> <h1 id="第四章-多线程编程"><a href="#第四章-多线程编程" class="header-anchor">#</a> 第四章 多线程编程</h1> <p>现在大多数是<strong>一个进程包含多个线程</strong></p> <p><strong>本章目标</strong>：</p> <ol><li>引入线程概念，即==CPU使用的基本单元==，构成==多线程计算机系统的基础==</li> <li>讨论==多线程编程==的相关问题</li></ol> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p><font color="red">每个线程是CPU使用的一个基本单元</font>，<strong>进程是系统的工作单元</strong>,<strong>同一个进程</strong>的其他<font color="red">线程共享代码段、数据段和其他操作系统资源</font></p> <p><img src="/learn-vuepress/assets/img/image-20210922212055730.75080ebb.png" alt="image-20210922212055730"></p> <h3 id="动机"><a href="#动机" class="header-anchor">#</a> 动机</h3> <p>为什么创建多个线程？</p> <ul><li>操作系统==创建==多个进程比一个进程创建多个线程的<strong>开销大</strong></li> <li>进程间==通信==和线程间通信更==复杂==</li></ul> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li>响应式：==部分阻塞==或执行冗余操作，==其他可以继续执行==，增加对用户的响应程度</li> <li>资源共享：进程共享通过内存和消息传递等技术，而==线程默认共享进程里的资源==</li> <li>经济：进程==创建非常昂贵==</li> <li>可伸缩性：线程可在==多处理器核上并行运行==</li></ul> <h2 id="多核编程"><a href="#多核编程" class="header-anchor">#</a> 多核编程</h2> <p>==改进并发性，成为并行性==</p> <p><img src="/learn-vuepress/assets/img/image-20210922213531247.0f6edf18.png" alt="image-20210922213531247"></p> <table><thead><tr><th style="text-align:center;">并行性</th> <th style="text-align:center;">并发性</th> <th style="text-align:center;">串行性</th></tr></thead> <tbody><tr><td style="text-align:center;">多核，==多个进程同时进行==</td> <td style="text-align:center;">==CPU上下文切换==，一个核，假象的并行性</td> <td style="text-align:center;">不用切换，==一个线程执行完，下一个接着==</td></tr></tbody></table> <p><img src="/learn-vuepress/assets/img/image-20210922214050740.b1f27129.png" alt="image-20210922214050740"></p> <p>Java中的高并发编程<font color="red">：一个线程睡眠，进程里的线程可能轮不到它执行，而执行了其他进程里的线程</font></p> <h2 id="多线程模型"><a href="#多线程模型" class="header-anchor">#</a> 多线程模型</h2> <p>两种方法<font color="red">提供线程支持</font>：</p> <p>用户层的==用户线程==：位于内核之上，<font color="red">无需内核支持</font></p> <p>内核层的==内核线程==：操作系统来支持与管理</p> <h3 id="多对一模型"><a href="#多对一模型" class="header-anchor">#</a> 多对一模型</h3> <p>缺点：</p> <ul><li><strong>一个线程阻塞</strong>，<font color="red">整个进程阻塞</font></li> <li>多个线程<font color="red">不能并行运行在多处理核系统</font></li></ul> <p><img src="/learn-vuepress/assets/img/image-20210923183604269.fee262de.png" alt="image-20210923183604269"></p> <h3 id="一对一模型"><a href="#一对一模型" class="header-anchor">#</a> 一对一模型</h3> <ul><li><font color="red">允许多个线程并行运行在多处理器上</font></li> <li>缺点：创建一个线程就创建一个内核线程，开销会影响性能</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210923183857637.2ceab718.png" alt="image-20210923183857637"></p> <h3 id="多对多模型"><a href="#多对多模型" class="header-anchor">#</a> 多对多模型</h3> <p><strong>多路复用</strong>：</p> <ul><li>==内核比用户线程少或者相等==</li> <li>一个线程阻塞，内核可以调用另一个线程来执行，==可以多处理器并行执行==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210923184124840.2e624ef0.png" alt="image-20210923184124840"></p> <p><strong>双层模型</strong>：</p> <ul><li>多对多的变种，==可以多路复用，也可以一对一==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210923184406372.a5784c35.png" alt="image-20210923184406372"></p> <h2 id="线程库"><a href="#线程库" class="header-anchor">#</a> 线程库</h2> <p>为程序员==提供创建和管理线程的API==</p> <h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <p><font color="red">线程加载到池中等待工作</font></p> <p>优点：</p> <ul><li>比等待创建一个线程快，因为存在</li> <li>限制创建线程数量</li> <li>将执行任务从创建任务的机制中分离出来</li></ul> <h1 id="第五章-进程调度"><a href="#第五章-进程调度" class="header-anchor">#</a> 第五章 进程调度</h1> <p><strong>本章目标</strong>：</p> <ul><li>==引入CPU调度，是多道程序操作系统的基础==</li> <li>描述<font color="red">各种CPU调度算法</font></li> <li>讨论特定系统选择CPU调度算法的<font color="red">评估标准</font></li> <li>分析多个操作系统的调度算法</li></ul> <h2 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h2> <p>多道程序：最大化CPU利用率</p> <p>操作系统选择==进程==，并交给CPU执行</p> <h3 id="cpu、i-o执行周期"><a href="#cpu、i-o执行周期" class="header-anchor">#</a> CPU、I/O执行周期</h3> <p><font color="red">进程在这两个状态之间不断交替</font></p> <p>IO密集型进程 &amp; CPU密集型进程：==主要看谁出现次数最多，就是谁==</p> <h3 id="cpu调度程序"><a href="#cpu调度程序" class="header-anchor">#</a> CPU调度程序</h3> <p>每当CPU空闲时，操作系统从就绪队列中选择一个进程来执行，<font color="green">PCB记录进程的情况</font></p> <h3 id="抢占调度"><a href="#抢占调度" class="header-anchor">#</a> 抢占调度</h3> <p><font color="red">CPU调度情况分为4种</font>：</p> <ol><li>运行---等待（IO请求）</li> <li>运行---就绪（中断）</li> <li>等待---就绪（IO设备好了）</li> <li>终止</li></ol> <p><strong>非抢占调度</strong>，一个进程分配到CPU，<font color="red">该进程一直使用该CPU，直到它终止或切换到等待</font></p> <h3 id="调度程序-2"><a href="#调度程序-2" class="header-anchor">#</a> 调度程序</h3> <p>==将CPU控制权交给短期调度程序==选择的进程</p> <p>功能：</p> <ul><li>切换上下文</li> <li>切换到用户模式</li> <li>跳转到用户程序的合适位置，以便重启程序</li></ul> <p><font color="red">调度延迟</font>：<strong>停止一个进程到启动另一个所需的时间</strong></p> <h2 id="调度准则"><a href="#调度准则" class="header-anchor">#</a> 调度准则</h2> <p>==最大化CPU使用率和吞吐量；==</p> <p>==最小化周转时间、等待时间和响应时间==</p> <p>方法：</p> <ul><li><strong>CPU使用率</strong>：<font color="red">40%（轻负荷）~90%（重负荷）</font></li> <li><strong>吞吐量</strong>：单位时间内进程完成的数量</li> <li><strong>周转时间</strong>：<font color="red">所有时间段之和</font>，包括：CPU、IO执行；就绪等待时间；等待时间</li> <li><strong>等待时间</strong>：<font color="red">就绪等待所花时间之和</font></li> <li><strong>响应时间</strong>：提交请求到产生第一响应的时间</li></ul> <h2 id="调度算法"><a href="#调度算法" class="header-anchor">#</a> 调度算法</h2> <p><font color="red">从就绪队列中选择进程以便为其分配CPU</font></p> <h3 id="先到先服务调度-fcfs"><a href="#先到先服务调度-fcfs" class="header-anchor">#</a> 先到先服务调度（FCFS）</h3> <p>==FCFS==：FIFO队列容易实现该算法，即==先请求CPU的进程首先分配到CPU==</p> <ul><li><strong>优点：算法实现简单</strong></li> <li><strong>缺点：平均等待时间往往很长</strong>，<strong>非抢占的</strong>，进程一直使用该分配的CPU，直到释放</li></ul> <h3 id="最短作业优先调度-sjf"><a href="#最短作业优先调度-sjf" class="header-anchor">#</a> 最短作业优先调度（SJF）</h3> <p>也叫最短下次CPU执行算法，<font color="red">调度取决于进程的下次CPU执行的长度</font></p> <ul><li><strong>优点：是最优的，平均等待时间最小</strong></li></ul> <p><img src="/learn-vuepress/assets/img/image-20210924115530265.e837045e.png" alt="image-20210924115530265"></p> <p>问题：如何知道下次CPU执行的长度？</p> <ul><li>对于<strong>批处理系统的长期调度</strong>，可以将用户提交作业时<font color="red">指定的进程时限作为长度</font></li> <li>短期调度：使用预测下次CPU执行长度，==认为下次CPU执行长度与以前的类似==</li></ul> <p>SJF算法可以是抢占式或非抢占式，<font color="red">抢占式抢占当前运行进程（最短剩余时间优先调度）</font></p> <p><img src="/learn-vuepress/assets/img/image-20210924120330827.dabb5a57.png" alt="image-20210924120330827"></p> <h3 id="优先级调度"><a href="#优先级调度" class="header-anchor">#</a> 优先级调度</h3> <ul><li>==按照优先级分配CPU==</li> <li>可以是抢占的或非抢占的</li> <li>导致问题是<font color="red">无穷阻塞或饥饿</font>，即优先级太低，而<strong>其他进来的进程比它高，一直在等待</strong>，解决方法：<font color="red">老化</font>，即长时间没有分配CPU，则<strong>把它优先级调高</strong></li></ul> <p><img src="/learn-vuepress/assets/img/image-20210924121007282.9d46c2c9.png" alt="image-20210924121007282"></p> <h3 id="轮转调度-rr"><a href="#轮转调度-rr" class="header-anchor">#</a> 轮转调度（RR）</h3> <ul><li>专门为<strong>分时系统设计类似于FCFS（先进先服务）</strong>，==但增加了抢占以切换进程==</li> <li><strong>时间片到，中断操作系统，进行上下文切换</strong></li> <li>==平均等待时间通常较长==</li> <li><font color="red">抢占式</font>，时间片到则抢占</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210924123213329.64f1a36c.png" alt="image-20210924123213329"></p> <h3 id="多级队列调度"><a href="#多级队列调度" class="header-anchor">#</a> 多级队列调度</h3> <p>将==就绪队列分成多个单独队列==，队列<font color="red">有自己的调度算法</font>，根据<strong>内存</strong>大小、进程<strong>优先级</strong>、<strong>进程类型</strong>等划分单独队列</p> <ul><li><strong>优点：优先级高的进程优先执行</strong></li> <li><strong>缺点：存在饥饿问题</strong></li> <li><img src="/learn-vuepress/assets/img/image-20210924201548572.5028d357.png" alt="image-20210924201548572"></li></ul> <h3 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="header-anchor">#</a> 多级反馈队列调度</h3> <p>允许进程在队列之间迁移，==如果进程使用过多的CPU时间，迁到更低的优先级队列==</p> <p>将<font color="red">IO密集型放在更高优先级</font>，因为<font color="red">IO得等待IO设备</font>，这样低的优先级也能有机会执行，<font color="red">防止饥饿</font></p> <h2 id="多处理器调度"><a href="#多处理器调度" class="header-anchor">#</a> 多处理器调度</h2> <p><font color="red">多个CPU</font>，则可以<font color="red">负载分配</font></p> <h3 id="多处理器调度的方法"><a href="#多处理器调度的方法" class="header-anchor">#</a> 多处理器调度的方法</h3> <ul><li>多处理器系统：<font color="red">一个处理器</font>处理所有调度决定、IO处理以及其他系统活动<font color="red">，其他处理器只执行用户代码</font></li> <li>==多对称处理（SMP）==：每个处理器自我调度</li></ul> <h3 id="处理器亲和性"><a href="#处理器亲和性" class="header-anchor">#</a> 处理器亲和性</h3> <p>让一个进程运行在同一个处理器上，即==切换进程时，CPU不变==，即一个进程对它运行的处理器具有亲和性</p> <ul><li>软亲和性：进程也可迁移到其他处理器上</li> <li>硬亲和性：允许进程运行在某个处理器子集上</li></ul> <h3 id="负载平衡"><a href="#负载平衡" class="header-anchor">#</a> 负载平衡</h3> <p>==将负载平均分配到SMP系统的所有处理器==，抵消处理器亲和性的好处，并行实现</p> <p>两种方法：</p> <ul><li>推迁移：将<strong>超载处理器</strong>==推到==（push）<strong>不太忙的处理器</strong></li> <li>拉迁移：<strong>不太忙</strong>的处理器拉<strong>忙的</strong>处理器的进程</li></ul> <h2 id="实时cpu调度"><a href="#实时cpu调度" class="header-anchor">#</a> 实时CPU调度</h2> <ul><li><p>软实时系统：不保证调度关键实时进程，<font color="red">只保证优先于非关键进程</font></p></li> <li><p>硬实时系统：<font color="red">截止期限之前完成，之后完成的不算</font></p></li></ul> <h3 id="最小化延迟"><a href="#最小化延迟" class="header-anchor">#</a> 最小化延迟</h3> <ol><li><strong>中断延时：</strong></li></ol> <p>中断发生，操作系统会完成正在执行的指令，再确定==中断类型==，然后==保存当前进程的状态==，采用中断服务程序==（ISR）==，这些需要的时间为中断延时</p> <p><img src="/learn-vuepress/assets/img/image-20210925204209684.f33a1677.png" alt="image-20210925204209684"></p> <ol start="2"><li><strong>调度延时：</strong></li></ol> <p><font color="red">停止一个进程到启动另一个进程所需时间</font>，降低时间方法：==抢占式内核==</p> <p>调度延迟的冲突有两部分：</p> <ul><li><strong>抢占其他进程</strong></li> <li><strong>释放进程占有的资源</strong></li></ul> <p><img src="/learn-vuepress/assets/img/image-20210925204552483.3376ab1b.png" alt="image-20210925204552483"></p> <h3 id="优先权调度"><a href="#优先权调度" class="header-anchor">#</a> 优先权调度</h3> <p>实时操作系统的调度程序==支持抢占的、基于优先权的算法==，<strong>仅保证软实时</strong>功能</p> <p>调度进程的特性：</p> <ul><li><strong>周期性p</strong></li> <li><strong>处理时间t</strong></li> <li><strong>CPU截止期限d</strong></li> <li><strong>速率1/p</strong></li> <li><font color="red">关系：0&lt;=t&lt;=d&lt;=p</font></li></ul> <p><font color="red">硬实时：如果任务不能在截止期限完成，拒绝请求</font></p> <h3 id="单调速率调度"><a href="#单调速率调度" class="header-anchor">#</a> 单调速率调度</h3> <p>采用==抢占的、静态优先级==的策略，==周期越短，优先级越高==</p> <p>例：两个进程P1和P2，P1和P2的<strong>周期</strong>分别为50和100，P1和P2的<strong>处理时间</strong>分别为t1=20和t2=35.每个进程的<strong>截止期限</strong>要求在下一个周期开始之前完成CPU执行，<font color="red">周期比率t/p（CPU利用率）</font></p> <ul><li>==假设P2优先级比P1高，P1错过其截止期限==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210925213648467.f31b8df8.png" alt="image-20210925213648467"></p> <ul><li>==使用单调速率调度，P1优先级高于P2，因为其周期短==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210925214311284.42916d71.png" alt="image-20210925214311284"></p> <ul><li>==进程数量接近无穷时，CPU利用率接近69%，两个进程的CPU利用率是83%==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20210925214342893.12e47c81.png" alt="image-20210925214342893"></p> <h3 id="最早截止期限优先调度-earliest-deadline-first-edf"><a href="#最早截止期限优先调度-earliest-deadline-first-edf" class="header-anchor">#</a> 最早截止期限优先调度（Earliest-Deadline-First EDF）</h3> <ul><li>动态分配优先级，==截止期限越早，优先级越高==</li> <li>一个进程可运行时，<font color="red">向系统公布截止期限要求</font></li></ul> <p><img src="/learn-vuepress/assets/img/image-20210929203802766.14dcda20.png" alt="image-20210929203802766"></p> <ul><li>EDF调度不要求进程应是周期的</li></ul> <h3 id="比例分享调度"><a href="#比例分享调度" class="header-anchor">#</a> 比例分享调度</h3> <ul><li>调度程序在==所有应用之间分配T股==，A分配50股，B分配15股，C分配20股，剩余15股</li> <li>准入控制策略：<strong>如果新进程D请求30股，拒绝D</strong></li></ul> <h1 id="第六章-同步"><a href="#第六章-同步" class="header-anchor">#</a> 第六章 同步</h1> <p>==协作进程==能与系统内的<font color="red">其他进程</font>相互影响，<font color="red">共享数据的并发访问可能导致数据的不一致</font>，所以要维护数据的一致性</p> <p><strong>本章目标</strong></p> <ul><li>引入<font color="red">临界区问题，可以确保共享数据的一致性</font></li> <li>临界区问题的<strong>软件和硬件解决方案</strong></li> <li>分析<strong>进程同步的多个经典问题</strong></li> <li>探讨<strong>解决进程同步问题的多个工具</strong></li></ul> <h2 id="背景"><a href="#背景" class="header-anchor">#</a> 背景</h2> <ul><li><strong>进程可以并发或并行执行</strong>，可能问题：<strong>两个进程并发操作变量counter</strong></li> <li>本章大部分讨论的是，协作进程如何进行==进程同步和进程协作==</li></ul> <h2 id="临界区问题"><a href="#临界区问题" class="header-anchor">#</a> 临界区问题</h2> <p>==临界区==：每个进程有一段代码（即==公共的==）</p> <blockquote><p><strong>一个进程在临界区执行，其他进程不允许在临界区执行</strong></p></blockquote> <p>设计一个协议：</p> <p><img src="/learn-vuepress/assets/img/image-20211001171303661.13be1f43.png" alt="image-20211001171303661"></p> <p>临界区的解决方案满足3个要求：</p> <ol><li><strong>互斥</strong>：一个进程在临界区执行，其他不能在临界区执行</li> <li><strong>进步</strong>：如果没有进程在临界区执行，那么==想加入临界区的进程一定不在剩余区==</li> <li><strong>有限等待</strong>：==等待临界区的进程数量有限==</li></ol> <p><strong>处理操作系统临界区问题</strong>：==抢占式内核和非抢占式内核==</p> <h2 id="硬件同步"><a href="#硬件同步" class="header-anchor">#</a> 硬件同步</h2> <ul><li>基于加锁为前提，通过<font color="red">锁来保护临界区</font>，通过<font color="red">硬件指令来解决临界区问题</font></li></ul> <h2 id="互斥锁-自旋锁"><a href="#互斥锁-自旋锁" class="header-anchor">#</a> 互斥锁（自旋锁）</h2> <p>软件解决方法：==使用互斥锁，防止竞争条件==</p> <ul><li>进入临界区<strong>得到</strong>锁，函数==acquire==（）</li> <li>退出<strong>释放</strong>锁，函数==release==（）</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211001175605773.0939d45f.png" alt="image-20211001175605773"></p> <ul><li>busy wait（忙等待）：==其他进程在进入临界区是不断循环判断，所以也叫自旋锁==</li></ul> <blockquote><p>缺点：浪费CPU周期，不断循环while，优点：没有切换上下文，即其他进程和在临界区的进程没切换</p></blockquote> <h2 id="信号量"><a href="#信号量" class="header-anchor">#</a> 信号量</h2> <ul><li>信号量是一个==整型变量==</li> <li>==wait()和signal()==来访问</li> <li>对应P原语（测试）和V原语（增加）</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211001194008665.077cc05b.png" alt="image-20211001194008665"></p> <ul><li><font color="red">当一个进程修改信号量时，其他进程不可修改，测试和修改也不能被中断</font></li></ul> <h3 id="信号量的使用"><a href="#信号量的使用" class="header-anchor">#</a> 信号量的使用</h3> <p><strong>计数信号量和二进制信号量（类似互斥锁）</strong></p> <ul><li>控制访问具有多个实例的某种资源，==信号量的初值为可用资源数量==</li> <li>使用资源：执行==wait==（）</li> <li>释放资源：执行==signal==（）</li> <li>信号量的计数为0，其他想使用资源的进程将会阻塞</li></ul> <h3 id="死锁与饥饿"><a href="#死锁与饥饿" class="header-anchor">#</a> 死锁与饥饿</h3> <p>死锁：==两个或多个进程无限等待一个事件==，而该事件只能由==这些等待进程之一来产生==</p> <ul><li>假设S和Q初始值为1，两个进程经过第一次wait，计数都为0，一直在那等待</li> <li>与死锁相关的问题：<font color="red">无限阻塞或饥饿</font></li></ul> <p><img src="/learn-vuepress/assets/img/image-20211001195444270.366927f1.png" alt="image-20211001195444270"></p> <h3 id="优先级的反转"><a href="#优先级的反转" class="header-anchor">#</a> 优先级的反转</h3> <p>进程需要资源R，而R正在被进程L访问</p> <ul><li>优先级顺序：L&lt;M&lt;H</li> <li>如果不反转，进程H等待L使用完的资源（加锁了，要等待），而此时进程M运行，==抢占进程L（而M不需要资源R，所以锁对它没影响）==，影响了H等待</li> <li>==反转（优先级继承协议）：进程L暂时由H的优先级，而M抢占不了==</li></ul> <h2 id="经典同步问题"><a href="#经典同步问题" class="header-anchor">#</a> 经典同步问题</h2> <p><font color="red">使用信号量解决同步问题</font>：</p> <ul><li>有界缓存问题</li> <li>读写问题（写的时候要信号量，防止多个进程同时写）</li> <li>哲学家就餐问题</li></ul> <h3 id="有界缓冲问题"><a href="#有界缓冲问题" class="header-anchor">#</a> 有界缓冲问题</h3> <p>生产者和消费者共享以下数据：</p> <p><img src="/learn-vuepress/assets/img/image-20211001201942263.eb91eb03.png" alt="image-20211001201942263"></p> <ul><li>信号量mutex：初始化为1</li> <li>empty（生产后-1，可消费+1）：没有生产，为空（n)</li> <li>full（消费后-1，可生产+1）：生产满了，等待消费者消费(0，还没生产，所以初始消费为0)</li></ul> <p>==wait执行后-1，而signal执行后+1==</p> <p><img src="/learn-vuepress/assets/img/image-20211001202221971.60f1f3e3.png" alt="image-20211001202221971"><img src="/learn-vuepress/assets/img/image-20211001202242286.3ad7861d.png" alt="image-20211001202242286"></p> <h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="header-anchor">#</a> 哲学家就餐问题</h3> <p>哲学家只做两件事：思考和吃饭（两个叉子才能吃）</p> <ul><li>发生死锁，所有哲学家饿死</li> <li>每个叉子用一个信号量（1）表示，即每个人那右手边的叉子，拿完信号量为0</li> <li>==取余（很秒***）：即拿到本身，即2号拿2号叉子，3拿3，4拿0==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211001204306195.9d185c28.png" alt="image-20211001204306195"></p> <ul><li><p>死锁补救：</p> <ol><li>4个哲学家5个叉子</li> <li>==有一个哲学家==当<strong>两个叉子都可用时才拿起他们</strong>（相当于奉献自己的一个叉子）</li> <li>单号哲学家先拿起左边的叉子，接着拿右边，而双号先拿右边再拿左边</li></ol></li> <li><p>没有一个饿死，但可能有人会饥饿</p></li></ul> <h1 id="第七章-死锁"><a href="#第七章-死锁" class="header-anchor">#</a> 第七章 死锁</h1> <blockquote><p>多道程序中，多个进程竞争有限资源，如果申请的资源被其他等待进程占有（即打印机，键盘，一开始我占打印机，你占键盘，第二次我想占键盘，而你占打印机，因为<strong>同时需要对方的资源</strong>，所以一直等待），称为死锁</p></blockquote> <p><strong>本章目标</strong>：</p> <ul><li>==解释死锁==，即一组并发进程不能完成执行任务</li> <li>提出一些方法，==避免死锁==</li></ul> <h2 id="死锁特征"><a href="#死锁特征" class="header-anchor">#</a> 死锁特征</h2> <ul><li>进程永远不能完成</li></ul> <h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="header-anchor">#</a> 死锁的必要条件</h3> <p>四个条件（==死锁四个条件都成立，而四个条件成立不一定发生死锁==）：</p> <ul><li><strong>互斥</strong>：至少有一个资源处于非共享模式，即一个进程使用了，另一个进程等待</li> <li>==占有并等待==：占有一个资源，等待另一个资源</li> <li><strong>非抢占</strong>：资源不能被抢占</li> <li><strong>循环等待</strong>（意味着==占有并等待==）：A-B-C-A，即A等待资源被B占，B等待资源被C占，而C等待的资源被A占</li></ul> <h2 id="死锁预防"><a href="#死锁预防" class="header-anchor">#</a> 死锁预防</h2> <p>4个条件中一个不成立即可</p> <ul><li><p>互斥：只读就行</p></li> <li><p>占有并等待：</p> <ol><li>==每个进程再执行前申请获得所有资源==：即申请资源的系统调用在所有其他系统调用之前进行</li> <li>在没有资源时才可申请资源：==它申请其他资源时已释放自己占有的==</li> <li>缺点：第一个方法：资源利用率低；第二个方法：发生饥饿</li></ol></li> <li><p>非抢占：通常==在CPU寄存器和内存使用==，即可以保存和恢复，==不适用互斥锁和信号量==</p> <blockquote><p>一个进程申请的资源不能立即分配，那么它现在分配的资源都可被抢占，最后<strong>它原有的资源和申请的资源空闲时，它才重新执行</strong></p></blockquote></li> <li><p>循环等待：对所有资源排序，<font color="red">每个进程按递增顺序来申请资源</font>，保证进程所需资源被开始的进程占有即可</p></li></ul> <h2 id="死锁恢复"><a href="#死锁恢复" class="header-anchor">#</a> 死锁恢复</h2> <p>检测到死锁发生：</p> <ul><li>通知操作员处理死锁（操作硬件不可取）</li> <li>让系统从死锁自动恢复（recover）
<ol><li>中止进程（暴力不可取）</li> <li>==允许抢占资源==</li></ol></li></ul> <h1 id="第八章-内存管理策略"><a href="#第八章-内存管理策略" class="header-anchor">#</a> 第八章 内存管理策略</h1> <blockquote><ul><li>计算机系统主要执行程序，执行程序访问数据部分在内存里，为了提高CPU利用率和响应用户速度，<strong>内存必须保留多个进程</strong></li> <li>内存管理方法：分页和分段</li> <li>取决因素：系统的硬件设计</li></ul></blockquote> <p><strong>本章目标</strong>：</p> <ul><li>描述<font color="red">内存硬件的各种组织方法</font></li> <li>探讨进程<font color="red">内存分配的各种技术</font></li> <li>讨论现代计算机系统的<font color="red">分页如何工作</font></li></ul> <h2 id="背景-2"><a href="#背景-2" class="header-anchor">#</a> 背景</h2> <ul><li>内存：很大的字节数组组成，每个字节有自己的地址（即内存地址）</li></ul> <h3 id="基本硬件"><a href="#基本硬件" class="header-anchor">#</a> 基本硬件</h3> <ul><li><p>确保进程有==单独的内存空间==</p></li> <li><p>确定进程可以==访问的合法地址范围==</p></li> <li><p>两个寄存器：<font color="red">基地址和界限地址</font></p> <ol><li>基地址：合法的<strong>最小内存地址</strong></li> <li>界限地址：合法范围地址的<strong>范围大小</strong></li></ol> <p><img src="/learn-vuepress/assets/img/image-20211002105525613.8ef74979.png" alt="image-20211002105525613"></p></li></ul> <blockquote><p>只有操作系统可以操作基地址和界限地址，而不允许用户程序修改（即木马）</p></blockquote> <p><img src="/learn-vuepress/assets/img/image-20211002105603116.a5f3e24d.png" alt="image-20211002105603116"></p> <h3 id="地址绑定"><a href="#地址绑定" class="header-anchor">#</a> 地址绑定</h3> <ul><li>程序存放在磁盘中，执行时调入内存放在进程中</li> <li>输入队列：磁盘等待进入内存（即作业池，等待分配内存）</li></ul> <blockquote><p><strong>程序是存放在磁盘中，运行时得放在内存中成为进程</strong></p></blockquote> <hr> <ul><li>源程序地址：用符号表示</li> <li>编译器：符号地址----可重定位地址</li> <li>链接器：可重定位地址-----绝对地址</li></ul> <p>知道内存地址方法：</p> <ol><li>编译时：==编译时知道进程内存地址，生成绝对代码==，将来地址发送变化，<font color="red">需重新编译代码</font></li> <li>加载时：编译不知道地址，加载时知道，地址变化时需重新加载</li> <li>==执行时（常用）==：一个内存到另一个内存，执行时知道地址</li></ol> <p><img src="/learn-vuepress/assets/img/image-20211002111618538.0e270e97.png" alt="image-20211002111618538"></p> <h3 id="逻辑地址空间与物理地址空间"><a href="#逻辑地址空间与物理地址空间" class="header-anchor">#</a> 逻辑地址空间与物理地址空间</h3> <p>CPU地址：逻辑地址</p> <p>内存地址：物理地址</p> <ul><li><font color="red">编译和加载生成相同的逻辑地址和物理地址</font></li> <li>执行生成不相同
<ol><li><font color="red">逻辑地址（虚拟地址）：所有逻辑地址的集合为逻辑地址空间</font></li> <li>逻辑地址对应的物理地址集合为物理地址空间</li></ol></li></ul> <blockquote><p>逻辑地址到物理地址是由**内存管理单元MMU（Memory-Management Unit）**的硬件设备完成的，<strong>使用基地址寄存器（也叫重定位寄存器）</strong></p></blockquote> <ul><li>用户程序不会看到真实的物理地址，即访问0对应物理地址是14000</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002114426185.1cac5dcf.png" alt="image-20211002114426185"></p> <h3 id="动态加载"><a href="#动态加载" class="header-anchor">#</a> 动态加载</h3> <blockquote><p>更好的内存空间利用率，因为程序数据要经过内存，所以内存有限</p></blockquote> <ul><li>优点：只有一个程序被需要时，它才会被加载，节省内存</li></ul> <h2 id="交换"><a href="#交换" class="header-anchor">#</a> 交换</h2> <blockquote><p><strong>进程可以暂时交换到磁盘</strong>，让总的物理地址空间超过真实空间，增加了相同的多道程序程度</p></blockquote> <p><img src="/learn-vuepress/assets/img/image-20211002121635952.311aaf13.png" alt="image-20211002121635952"></p> <h3 id="标准交换-不用"><a href="#标准交换-不用" class="header-anchor">#</a> 标准交换（不用）</h3> <ul><li>当CPU调度器执行一个进程时，调用分派器，查询进程是否在内存中，不在则==换出（swap out）==内存的一个进程，并==换入（swap in）==所需进程</li> <li>缺点：耗时</li> <li>==变种（通常与虚拟内存工作）：==
<ol><li><font color="red">有多余内存空闲，开始交换</font></li> <li><font color="red">交换进程的部分</font></li></ol></li></ul> <h3 id="移动系统的交换"><a href="#移动系统的交换" class="header-anchor">#</a> 移动系统的交换</h3> <ul><li>移动不支持任何的交换，采用闪存，不用磁盘</li> <li>苹果iOS：<font color="red">要求重新自愿放弃分配内存，只读可删除</font></li> <li>Android：<font color="red">终止程序，写到闪存</font></li></ul> <blockquote><p>注意：iOS和Android支持分页，有内存管理能力</p></blockquote> <h2 id="连续内存分配"><a href="#连续内存分配" class="header-anchor">#</a> 连续内存分配</h2> <blockquote><p>内存分为两个区域：一个放操作系统，一个放用户进程</p></blockquote> <h3 id="内存保护"><a href="#内存保护" class="header-anchor">#</a> 内存保护</h3> <ul><li>防止进程访问其他内存</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002171251122.2fa9c7cd.png" alt="image-20211002171251122"></p> <h3 id="内存分配"><a href="#内存分配" class="header-anchor">#</a> 内存分配</h3> <blockquote><p>固定分区推广（MVT），用于批处理环境</p></blockquote> <ul><li>可变分区：操作系统有一个表，记录哪些内存可用和哪些已用</li> <li>内存有一个集合，包含各种大小的==孔（即内存的子集）==
<ol><li><font color="red">首次</font>适应（快）：一旦找到比它大的内存（孔）则停</li> <li><font color="red">最优</font>适应（好）：分配最小的孔，要排序</li> <li><font color="red">最差</font>适应（差）：分配最大的孔，排序拿最大的（==和首次区别在于首次是找到比它大就行，不一定是最大的==）</li></ol></li></ul> <h3 id="内存碎片"><a href="#内存碎片" class="header-anchor">#</a> 内存碎片</h3> <blockquote><p>即分配的孔没用完，孔地址之间不连续，<strong>导致孔的大小虽然满足，但是不可用</strong></p></blockquote> <p>解决方案：</p> <ul><li>==允许逻辑地址不连续==</li> <li>==两种互补技术：分段和分页==，两个技术组合</li></ul> <h2 id="分段"><a href="#分段" class="header-anchor">#</a> 分段</h2> <blockquote><p>内存管理方案</p></blockquote> <p><font color="red">逻辑地址由有序对组成《段号，偏移》</font></p> <ul><li>==段号：相当于索引==</li> <li>==偏移：即界限地址==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002175500028.9e2e6474.png" alt="image-20211002175500028"></p> <h3 id="基本方法"><a href="#基本方法" class="header-anchor">#</a> 基本方法</h3> <ul><li>程序会装入不同段，每个段都有段号</li></ul> <h3 id="分段硬件"><a href="#分段硬件" class="header-anchor">#</a> 分段硬件</h3> <blockquote><p>逻辑虽然是二维数组，而实际物理内存仍然是一维，所以定义一个段表</p> <p>==段表有段基地址和段界限==，<font color="red">索引到段表，然后两个界限判断，最后偏移加上基址成为最终物理地址</font></p></blockquote> <p><img src="/learn-vuepress/assets/img/image-20211002180416674.08789f50.png" alt="image-20211002180416674"></p> <h2 id="分页-重点"><a href="#分页-重点" class="header-anchor">#</a> 分页（重点）</h2> <blockquote><p><strong>分页避免了外部碎片，而分段不行</strong>；被大多数操作系统采用</p> <ul><li>内部碎片：即分配给它的内存没用完</li> <li>外部碎片：帧和页大小相同，解决了碎片</li></ul></blockquote> <h3 id="基本方法-2"><a href="#基本方法-2" class="header-anchor">#</a> 基本方法</h3> <p>分段大小不固定，分页大小固定</p> <ul><li>==物理内存：帧或页帧==</li> <li>==逻辑内存：页或页面==</li> <li><font color="red">页码</font>（对应页表的索引）和页偏移</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002191123931.744d28a3.png" alt="image-20211002191123931"></p> <p><img src="/learn-vuepress/assets/img/image-20211002191611822.05aa064d.png" alt="image-20211002191611822"></p> <p>==页大小(2的幂)==2 ^ n</p> <ul><li><p>例：n=2,m=4,==4字节对应32字节内存，页大小2的二次方=4；==</p> <p><img src="/learn-vuepress/assets/img/image-20211002192631317.d99bc5be.png" alt="image-20211002192631317"></p></li> <li><p>==n页对应n帧，分配完更新==</p></li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002192952272.5d3d7106.png" alt="image-20211002192952272"></p> <h3 id="硬件支持"><a href="#硬件支持" class="header-anchor">#</a> 硬件支持</h3> <blockquote><p>比之前多一个TLB（转换表缓冲区 Translation Look-aside Buffer），搜索速度快</p></blockquote> <ul><li>如果不在则称为==TLB未命中==，==此时需要访问页表==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002194510268.97fff46b.png" alt="image-20211002194510268"></p> <h3 id="共享页"><a href="#共享页" class="header-anchor">#</a> 共享页</h3> <blockquote><p>共享公共代码，但数据不行</p></blockquote> <ul><li>代码是==可重入代码或纯代码，执行期间不可修改==</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002194943763.f12b9f77.png" alt="image-20211002194943763"></p> <h2 id="页表结构"><a href="#页表结构" class="header-anchor">#</a> 页表结构</h2> <blockquote><p>分层分页、哈希页表、倒置页表</p></blockquote> <table><thead><tr><th style="text-align:center;">分层分页</th> <th style="text-align:center;">哈希页表</th> <th style="text-align:center;">倒置页表</th></tr></thead> <tbody><tr><td style="text-align:center;">页表太大，将==页表划分==</td> <td style="text-align:center;">虚拟页码，映射帧码，下一个元素的指针</td> <td style="text-align:center;">整个系统==只有一个页表==，缺点：==查找页表时间长，不能共享内存==</td></tr> <tr><td style="text-align:center;"><img src="/learn-vuepress/assets/img/image-20211002201819579.8c6c0c55.png" alt="image-20211002201819579"></td> <td style="text-align:center;"><img src="/learn-vuepress/assets/img/image-20211002202226147.d2677361.png" alt="image-20211002202226147"></td> <td style="text-align:center;"><img src="/learn-vuepress/assets/img/image-20211002202513602.bec6601b.png" alt="image-20211002202513602"></td></tr> <tr><td style="text-align:center;">p1外部页表索引，p2内部页表的偏移，由于外到内，叫==向前映射页表==</td> <td style="text-align:center;"></td> <td style="text-align:center;">虚拟地址：《进程pid，页码，偏移》</td></tr> <tr><td style="text-align:center;"><img src="/learn-vuepress/assets/img/image-20211002202009729.baa77370.png" alt="image-20211002202009729"></td> <td style="text-align:center;"></td> <td style="text-align:center;">倒置页表：《进程pid，页码》</td></tr></tbody></table> <h1 id="第九章-虚拟内存管理"><a href="#第九章-虚拟内存管理" class="header-anchor">#</a> 第九章 虚拟内存管理</h1> <blockquote><p>之前说是所有进程执行前应在内存中</p></blockquote> <ul><li>虚拟内存技术允许进程不必处于内存，<strong>实现逻辑内存和物理内存分离</strong></li></ul> <p><strong>本章目标：</strong></p> <ul><li>讨论虚拟内存系统的优点</li> <li>解释<font color="red">请求调页、页置换算法和页帧分配</font></li> <li>讨论<strong>工作集模型</strong>原理</li> <li>讨论<strong>共享内存和内存映射文件之间</strong>的关系</li></ul> <h2 id="背景-3"><a href="#背景-3" class="header-anchor">#</a> 背景</h2> <blockquote><p>一些报异常代码很少用到，所以没必要放到内存</p></blockquote> <ul><li>分段==执行部分==处于内存的程序优点：
<ol><li>程序不受内存限制</li> <li>增加CPU利用率和吞吐量</li> <li>时间没变化（还是用到IO设备）</li></ol></li></ul> <p><img src="/learn-vuepress/assets/img/image-20211002211121694.824633b3.png" alt="image-20211002211121694"></p> <p>==进程的虚拟地址空间==</p> <p><img src="/learn-vuepress/assets/img/image-20211002211543016.0f5bf08a.png" alt="image-20211002211543016"></p> <h2 id="请求调页-换入"><a href="#请求调页-换入" class="header-anchor">#</a> 请求调页（换入）</h2> <blockquote><p>用于虚拟内存系统，即<font color="red">用到那个就从磁盘取到内存（惰性交换器）</font>，类似交换</p></blockquote> <ul><li>使用==调页程序==：涉及进程的页面</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211003173154934.ac881fa8.png" alt="image-20211003173154934"></p> <h3 id="基本概念-2"><a href="#基本概念-2" class="header-anchor">#</a> 基本概念</h3> <p>硬件支持：<font color="red">区分内存的页面和磁盘的页面</font></p> <ul><li>使用有效(valid)-无效(invalid)位方案</li> <li>无效：可能是真不存在，或者它存在磁盘中</li></ul> <p><img src="/learn-vuepress/assets/img/image-20211003173419937.78d8a7fe.png" alt="image-20211003173419937"></p> <ul><li>对<font color="red">标记无效的页面访问会产生缺页错误</font></li> <li>解决方法：
<ol><li>检查页表</li> <li>如果引用无效，终止进程==，引用有效但是未调入页面，就调入页面==</li> <li>找到空闲帧</li> <li>从磁盘读取到空闲的帧里</li> <li>==修改进程页表，标识页处于内存中==</li> <li>==重新启动被陷阱中断的指令==</li></ol></li></ul> <p><img src="/learn-vuepress/assets/img/image-20211003174925826.e0812460.png" alt="image-20211003174925826"></p> <ul><li>纯请求调页：需要时才将页面调入内存</li> <li>一个指令可能引起多个缺页错误，导致不可接受的系统性能（几乎不可能）
<ul><li>==程序具有局部引用，使得请求调页合理==</li></ul></li></ul> <h2 id="页面置换-换出"><a href="#页面置换-换出" class="header-anchor">#</a> 页面置换（换出）</h2> <blockquote><p>内存已满，想在换入时，得换出一些（页面置换）</p></blockquote> <h3 id="fifo页面置换"><a href="#fifo页面置换" class="header-anchor">#</a> FIFO页面置换</h3> <blockquote><p>最简单的算法：先进先出，选择最旧的页面换出</p></blockquote> <h3 id="最优页面置换"><a href="#最优页面置换" class="header-anchor">#</a> 最优页面置换</h3> <blockquote><p>置换最长时间没使用的页面</p></blockquote> <ul><li>和FIFO有区别：==它是长时间没用，而FIFO是满了==，它可能被换出之前使用了，但<font color="red">由于已满必须得换出</font></li></ul> <h3 id="lru页面置换"><a href="#lru页面置换" class="header-anchor">#</a> LRU页面置换</h3> <p>Least-Recent-Used：最近最少使用，==将每个页面和上次使用的时间关联起来，计算时间差==</p> <h3 id="基于计数的页面置换"><a href="#基于计数的页面置换" class="header-anchor">#</a> 基于计数的页面置换</h3> <blockquote><p>计数器</p></blockquote> <ul><li>最不经常使用（Least Frequently Used ，LFU）：==要求置换最小计数的页面==，具有最大计数的，如果长时间不用会--</li> <li>最经常使用（Most Frequently Used，MFU）：基于以下论点：最小计数的页面可能是刚换入的，==看使用频率==</li></ul> <h2 id="帧分配"><a href="#帧分配" class="header-anchor">#</a> 帧分配</h2> <blockquote><p>每个进程分配多少帧</p></blockquote> <h3 id="帧的最小数"><a href="#帧的最小数" class="header-anchor">#</a> 帧的最小数</h3> <blockquote><p>即分配接近和进程所需的帧</p></blockquote> <h3 id="分配算法"><a href="#分配算法" class="header-anchor">#</a> 分配算法</h3> <ul><li>平均分配：每个进程分配相同数量的帧</li> <li>按比例分配：进程占用内存越大，分配帧越多，==它不确保每个进程所分配的帧接近其所需的==</li></ul> <h3 id="全局分配与局部分配"><a href="#全局分配与局部分配" class="header-anchor">#</a> 全局分配与局部分配</h3> <blockquote><p><strong>分配帧的一个重要因素是页面置换</strong></p></blockquote> <ul><li>页面置换算法
<ul><li>==全局置换：一个进程可以从另一个进程获取帧==</li> <li>局部置换：进程之间不可交互</li></ul></li></ul> <h2 id="系统抖动"><a href="#系统抖动" class="header-anchor">#</a> 系统抖动</h2> <blockquote><p>抖动：页面调度活动，一个进行调页时间多于它的执行时间</p></blockquote> <h3 id="系统抖动的原因"><a href="#系统抖动的原因" class="header-anchor">#</a> 系统抖动的原因</h3> <ul><li>产生缺页错误，其他所有页面都在使用，==你抢它的页面，而它又去抢别的，导致很大进程等待调页设备（IO设备很耗时），CPU利用率降低==</li></ul> <p>解决抖动问题：</p> <ul><li>==通过局部置换算法，即不影响其他的进程==</li> <li>缺页错误频率：设置缺页错误率的上下限
<ul><li>错误率过高：增加进程的帧数</li> <li>过低：减少帧数</li></ul></li></ul> <h3 id="内存映射文件"><a href="#内存映射文件" class="header-anchor">#</a> 内存映射文件</h3> <blockquote><p>将文件I/O作为常规内存访问，允许==部分虚拟内存与文件进行逻辑关联==</p></blockquote> <p><img src="/learn-vuepress/assets/img/image-20211003194942762.cebc9326.png" alt="image-20211003194942762"></p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/learn-vuepress/computer/Linux.html" class="prev">
            Linux
          </a></span> <span class="next"><a href="/learn-vuepress/interview/interview.html">
            面试必备
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的功能" class="sidebar-link reco-side-操作系统的功能" data-v-cb1513f6>操作系统的功能</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的定义" class="sidebar-link reco-side-操作系统的定义" data-v-cb1513f6>操作系统的定义</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#计算机系统的组成" class="sidebar-link reco-side-计算机系统的组成" data-v-cb1513f6>计算机系统的组成</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#计算机系统的运行" class="sidebar-link reco-side-计算机系统的运行" data-v-cb1513f6>计算机系统的运行</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#存储结构" class="sidebar-link reco-side-存储结构" data-v-cb1513f6>存储结构</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#i-o结构" class="sidebar-link reco-side-i-o结构" data-v-cb1513f6>I/O结构</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#计算机系统的体系结构" class="sidebar-link reco-side-计算机系统的体系结构" data-v-cb1513f6>计算机系统的体系结构</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#单处理器系统" class="sidebar-link reco-side-单处理器系统" data-v-cb1513f6>单处理器系统</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多处理器系统" class="sidebar-link reco-side-多处理器系统" data-v-cb1513f6>多处理器系统</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#集群系统" class="sidebar-link reco-side-集群系统" data-v-cb1513f6>集群系统</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的结构" class="sidebar-link reco-side-操作系统的结构" data-v-cb1513f6>操作系统的结构</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的执行" class="sidebar-link reco-side-操作系统的执行" data-v-cb1513f6>操作系统的执行</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#双重模式与多重模式的执行" class="sidebar-link reco-side-双重模式与多重模式的执行" data-v-cb1513f6>双重模式与多重模式的执行</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#定时器" class="sidebar-link reco-side-定时器" data-v-cb1513f6>定时器</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程管理" class="sidebar-link reco-side-进程管理" data-v-cb1513f6>进程管理</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#内存管理" class="sidebar-link reco-side-内存管理" data-v-cb1513f6>内存管理</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#存储管理" class="sidebar-link reco-side-存储管理" data-v-cb1513f6>存储管理</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#高速缓存" class="sidebar-link reco-side-高速缓存" data-v-cb1513f6>高速缓存</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#i-o系统" class="sidebar-link reco-side-i-o系统" data-v-cb1513f6>I/O系统</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#保护与安全" class="sidebar-link reco-side-保护与安全" data-v-cb1513f6>保护与安全</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#计算环境" class="sidebar-link reco-side-计算环境" data-v-cb1513f6>计算环境</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分布计算" class="sidebar-link reco-side-分布计算" data-v-cb1513f6>分布计算</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#客户机-服务器计算" class="sidebar-link reco-side-客户机-服务器计算" data-v-cb1513f6>客户机-服务器计算</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#对等计算" class="sidebar-link reco-side-对等计算" data-v-cb1513f6>对等计算</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#虚拟化" class="sidebar-link reco-side-虚拟化" data-v-cb1513f6>虚拟化</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#云计算" class="sidebar-link reco-side-云计算" data-v-cb1513f6>云计算</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#实时嵌入式系统" class="sidebar-link reco-side-实时嵌入式系统" data-v-cb1513f6>实时嵌入式系统</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#开源操作系统" class="sidebar-link reco-side-开源操作系统" data-v-cb1513f6>开源操作系统</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的服务" class="sidebar-link reco-side-操作系统的服务" data-v-cb1513f6>操作系统的服务</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#用户与操作系统的界面" class="sidebar-link reco-side-用户与操作系统的界面" data-v-cb1513f6>用户与操作系统的界面</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#命令解释程序" class="sidebar-link reco-side-命令解释程序" data-v-cb1513f6>命令解释程序</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#图形用户界面" class="sidebar-link reco-side-图形用户界面" data-v-cb1513f6>图形用户界面</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#系统调用" class="sidebar-link reco-side-系统调用" data-v-cb1513f6>系统调用</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#系统调用的类型" class="sidebar-link reco-side-系统调用的类型" data-v-cb1513f6>系统调用的类型</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程控制" class="sidebar-link reco-side-进程控制" data-v-cb1513f6>进程控制</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#操作系统的结构-2" class="sidebar-link reco-side-操作系统的结构-2" data-v-cb1513f6>操作系统的结构</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分层方法" class="sidebar-link reco-side-分层方法" data-v-cb1513f6>分层方法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#微内核" class="sidebar-link reco-side-微内核" data-v-cb1513f6>微内核</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#模块" class="sidebar-link reco-side-模块" data-v-cb1513f6>模块</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#混合系统" class="sidebar-link reco-side-混合系统" data-v-cb1513f6>混合系统</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#系统引导" class="sidebar-link reco-side-系统引导" data-v-cb1513f6>系统引导</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程概念" class="sidebar-link reco-side-进程概念" data-v-cb1513f6>进程概念</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程" class="sidebar-link reco-side-进程" data-v-cb1513f6>进程</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程状态" class="sidebar-link reco-side-进程状态" data-v-cb1513f6>进程状态</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程控制块" class="sidebar-link reco-side-进程控制块" data-v-cb1513f6>进程控制块</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程调度" class="sidebar-link reco-side-进程调度" data-v-cb1513f6>进程调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#调度队列" class="sidebar-link reco-side-调度队列" data-v-cb1513f6>调度队列</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#调度程序" class="sidebar-link reco-side-调度程序" data-v-cb1513f6>调度程序</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#上下文切换" class="sidebar-link reco-side-上下文切换" data-v-cb1513f6>上下文切换</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程运行" class="sidebar-link reco-side-进程运行" data-v-cb1513f6>进程运行</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程创建" class="sidebar-link reco-side-进程创建" data-v-cb1513f6>进程创建</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程终止" class="sidebar-link reco-side-进程终止" data-v-cb1513f6>进程终止</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#进程间通信" class="sidebar-link reco-side-进程间通信" data-v-cb1513f6>进程间通信</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#客户机-服务器通信" class="sidebar-link reco-side-客户机-服务器通信" data-v-cb1513f6>客户机/服务器通信</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#套接字" class="sidebar-link reco-side-套接字" data-v-cb1513f6>套接字</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#远程过程调用" class="sidebar-link reco-side-远程过程调用" data-v-cb1513f6>远程过程调用</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#管道" class="sidebar-link reco-side-管道" data-v-cb1513f6>管道</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#概述" class="sidebar-link reco-side-概述" data-v-cb1513f6>概述</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#动机" class="sidebar-link reco-side-动机" data-v-cb1513f6>动机</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#优点" class="sidebar-link reco-side-优点" data-v-cb1513f6>优点</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多核编程" class="sidebar-link reco-side-多核编程" data-v-cb1513f6>多核编程</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多线程模型" class="sidebar-link reco-side-多线程模型" data-v-cb1513f6>多线程模型</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多对一模型" class="sidebar-link reco-side-多对一模型" data-v-cb1513f6>多对一模型</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#一对一模型" class="sidebar-link reco-side-一对一模型" data-v-cb1513f6>一对一模型</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多对多模型" class="sidebar-link reco-side-多对多模型" data-v-cb1513f6>多对多模型</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#线程库" class="sidebar-link reco-side-线程库" data-v-cb1513f6>线程库</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#线程池" class="sidebar-link reco-side-线程池" data-v-cb1513f6>线程池</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基本概念" class="sidebar-link reco-side-基本概念" data-v-cb1513f6>基本概念</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#cpu、i-o执行周期" class="sidebar-link reco-side-cpu、i-o执行周期" data-v-cb1513f6>CPU、I/O执行周期</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#cpu调度程序" class="sidebar-link reco-side-cpu调度程序" data-v-cb1513f6>CPU调度程序</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#抢占调度" class="sidebar-link reco-side-抢占调度" data-v-cb1513f6>抢占调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#调度程序-2" class="sidebar-link reco-side-调度程序-2" data-v-cb1513f6>调度程序</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#调度准则" class="sidebar-link reco-side-调度准则" data-v-cb1513f6>调度准则</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#调度算法" class="sidebar-link reco-side-调度算法" data-v-cb1513f6>调度算法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#先到先服务调度-fcfs" class="sidebar-link reco-side-先到先服务调度-fcfs" data-v-cb1513f6>先到先服务调度（FCFS）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#最短作业优先调度-sjf" class="sidebar-link reco-side-最短作业优先调度-sjf" data-v-cb1513f6>最短作业优先调度（SJF）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#优先级调度" class="sidebar-link reco-side-优先级调度" data-v-cb1513f6>优先级调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#轮转调度-rr" class="sidebar-link reco-side-轮转调度-rr" data-v-cb1513f6>轮转调度（RR）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多级队列调度" class="sidebar-link reco-side-多级队列调度" data-v-cb1513f6>多级队列调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多级反馈队列调度" class="sidebar-link reco-side-多级反馈队列调度" data-v-cb1513f6>多级反馈队列调度</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多处理器调度" class="sidebar-link reco-side-多处理器调度" data-v-cb1513f6>多处理器调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#多处理器调度的方法" class="sidebar-link reco-side-多处理器调度的方法" data-v-cb1513f6>多处理器调度的方法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#处理器亲和性" class="sidebar-link reco-side-处理器亲和性" data-v-cb1513f6>处理器亲和性</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#负载平衡" class="sidebar-link reco-side-负载平衡" data-v-cb1513f6>负载平衡</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#实时cpu调度" class="sidebar-link reco-side-实时cpu调度" data-v-cb1513f6>实时CPU调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#最小化延迟" class="sidebar-link reco-side-最小化延迟" data-v-cb1513f6>最小化延迟</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#优先权调度" class="sidebar-link reco-side-优先权调度" data-v-cb1513f6>优先权调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#单调速率调度" class="sidebar-link reco-side-单调速率调度" data-v-cb1513f6>单调速率调度</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#最早截止期限优先调度-earliest-deadline-first-edf" class="sidebar-link reco-side-最早截止期限优先调度-earliest-deadline-first-edf" data-v-cb1513f6>最早截止期限优先调度（Earliest-Deadline-First EDF）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#比例分享调度" class="sidebar-link reco-side-比例分享调度" data-v-cb1513f6>比例分享调度</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#背景" class="sidebar-link reco-side-背景" data-v-cb1513f6>背景</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#临界区问题" class="sidebar-link reco-side-临界区问题" data-v-cb1513f6>临界区问题</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#硬件同步" class="sidebar-link reco-side-硬件同步" data-v-cb1513f6>硬件同步</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#互斥锁-自旋锁" class="sidebar-link reco-side-互斥锁-自旋锁" data-v-cb1513f6>互斥锁（自旋锁）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#信号量" class="sidebar-link reco-side-信号量" data-v-cb1513f6>信号量</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#信号量的使用" class="sidebar-link reco-side-信号量的使用" data-v-cb1513f6>信号量的使用</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#死锁与饥饿" class="sidebar-link reco-side-死锁与饥饿" data-v-cb1513f6>死锁与饥饿</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#优先级的反转" class="sidebar-link reco-side-优先级的反转" data-v-cb1513f6>优先级的反转</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#经典同步问题" class="sidebar-link reco-side-经典同步问题" data-v-cb1513f6>经典同步问题</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#有界缓冲问题" class="sidebar-link reco-side-有界缓冲问题" data-v-cb1513f6>有界缓冲问题</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#哲学家就餐问题" class="sidebar-link reco-side-哲学家就餐问题" data-v-cb1513f6>哲学家就餐问题</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#死锁特征" class="sidebar-link reco-side-死锁特征" data-v-cb1513f6>死锁特征</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#死锁的必要条件" class="sidebar-link reco-side-死锁的必要条件" data-v-cb1513f6>死锁的必要条件</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#死锁预防" class="sidebar-link reco-side-死锁预防" data-v-cb1513f6>死锁预防</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#死锁恢复" class="sidebar-link reco-side-死锁恢复" data-v-cb1513f6>死锁恢复</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#背景-2" class="sidebar-link reco-side-背景-2" data-v-cb1513f6>背景</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基本硬件" class="sidebar-link reco-side-基本硬件" data-v-cb1513f6>基本硬件</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#地址绑定" class="sidebar-link reco-side-地址绑定" data-v-cb1513f6>地址绑定</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#逻辑地址空间与物理地址空间" class="sidebar-link reco-side-逻辑地址空间与物理地址空间" data-v-cb1513f6>逻辑地址空间与物理地址空间</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#动态加载" class="sidebar-link reco-side-动态加载" data-v-cb1513f6>动态加载</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#交换" class="sidebar-link reco-side-交换" data-v-cb1513f6>交换</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#标准交换-不用" class="sidebar-link reco-side-标准交换-不用" data-v-cb1513f6>标准交换（不用）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#移动系统的交换" class="sidebar-link reco-side-移动系统的交换" data-v-cb1513f6>移动系统的交换</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#连续内存分配" class="sidebar-link reco-side-连续内存分配" data-v-cb1513f6>连续内存分配</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#内存保护" class="sidebar-link reco-side-内存保护" data-v-cb1513f6>内存保护</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#内存分配" class="sidebar-link reco-side-内存分配" data-v-cb1513f6>内存分配</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#内存碎片" class="sidebar-link reco-side-内存碎片" data-v-cb1513f6>内存碎片</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分段" class="sidebar-link reco-side-分段" data-v-cb1513f6>分段</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基本方法" class="sidebar-link reco-side-基本方法" data-v-cb1513f6>基本方法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分段硬件" class="sidebar-link reco-side-分段硬件" data-v-cb1513f6>分段硬件</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分页-重点" class="sidebar-link reco-side-分页-重点" data-v-cb1513f6>分页（重点）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基本方法-2" class="sidebar-link reco-side-基本方法-2" data-v-cb1513f6>基本方法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#硬件支持" class="sidebar-link reco-side-硬件支持" data-v-cb1513f6>硬件支持</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#共享页" class="sidebar-link reco-side-共享页" data-v-cb1513f6>共享页</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#页表结构" class="sidebar-link reco-side-页表结构" data-v-cb1513f6>页表结构</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#背景-3" class="sidebar-link reco-side-背景-3" data-v-cb1513f6>背景</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#请求调页-换入" class="sidebar-link reco-side-请求调页-换入" data-v-cb1513f6>请求调页（换入）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基本概念-2" class="sidebar-link reco-side-基本概念-2" data-v-cb1513f6>基本概念</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#页面置换-换出" class="sidebar-link reco-side-页面置换-换出" data-v-cb1513f6>页面置换（换出）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#fifo页面置换" class="sidebar-link reco-side-fifo页面置换" data-v-cb1513f6>FIFO页面置换</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#最优页面置换" class="sidebar-link reco-side-最优页面置换" data-v-cb1513f6>最优页面置换</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#lru页面置换" class="sidebar-link reco-side-lru页面置换" data-v-cb1513f6>LRU页面置换</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#基于计数的页面置换" class="sidebar-link reco-side-基于计数的页面置换" data-v-cb1513f6>基于计数的页面置换</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#帧分配" class="sidebar-link reco-side-帧分配" data-v-cb1513f6>帧分配</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#帧的最小数" class="sidebar-link reco-side-帧的最小数" data-v-cb1513f6>帧的最小数</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#分配算法" class="sidebar-link reco-side-分配算法" data-v-cb1513f6>分配算法</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#全局分配与局部分配" class="sidebar-link reco-side-全局分配与局部分配" data-v-cb1513f6>全局分配与局部分配</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#系统抖动" class="sidebar-link reco-side-系统抖动" data-v-cb1513f6>系统抖动</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#系统抖动的原因" class="sidebar-link reco-side-系统抖动的原因" data-v-cb1513f6>系统抖动的原因</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-vuepress/computer/os.html#内存映射文件" class="sidebar-link reco-side-内存映射文件" data-v-cb1513f6>内存映射文件</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/learn-vuepress/assets/js/app.58b32b08.js" defer></script><script src="/learn-vuepress/assets/js/6.0c5ddd61.js" defer></script><script src="/learn-vuepress/assets/js/1.a3f35cab.js" defer></script><script src="/learn-vuepress/assets/js/4.c6620eae.js" defer></script>
  </body>
</html>
