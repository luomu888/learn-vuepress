(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{740:function(t,v,_){t.exports=_.p+"assets/img/image-20210919173306318.8c4c52f4.png"},741:function(t,v,_){t.exports=_.p+"assets/img/image-20210919184751935.958a33ce.png"},742:function(t,v,_){t.exports=_.p+"assets/img/image-20210919184838712.48383438.png"},743:function(t,v,_){t.exports=_.p+"assets/img/image-20210919195652501.4ec98c75.png"},744:function(t,v,_){t.exports=_.p+"assets/img/image-20210919202020157.2fbc990e.png"},745:function(t,v,_){t.exports=_.p+"assets/img/image-20210919204200261.459a61d3.png"},746:function(t,v,_){t.exports=_.p+"assets/img/image-20210919211616166.ccd66395.png"},747:function(t,v,_){t.exports=_.p+"assets/img/image-20210919220923783.5ea17214.png"},748:function(t,v,_){t.exports=_.p+"assets/img/image-20210919221301434.7d240af2.png"},749:function(t,v,_){t.exports=_.p+"assets/img/image-20210920165829052.5c5d1dad.png"},750:function(t,v,_){t.exports=_.p+"assets/img/image-20210920170100313.ca90c6d1.png"},751:function(t,v,_){t.exports=_.p+"assets/img/image-20210920170433227.7af198aa.png"},752:function(t,v,_){t.exports=_.p+"assets/img/image-20210920170644021.2741656d.png"},753:function(t,v,_){t.exports=_.p+"assets/img/image-20210920175536363.106782c9.png"},754:function(t,v,_){t.exports=_.p+"assets/img/image-20210920182605130.6d0606fd.png"},755:function(t,v,_){t.exports=_.p+"assets/img/image-20210920182351818.7a6142b6.png"},756:function(t,v,_){t.exports=_.p+"assets/img/image-20210920190836313.be99760e.png"},757:function(t,v,_){t.exports=_.p+"assets/img/image-20210920191614585.930bdc88.png"},758:function(t,v,_){t.exports=_.p+"assets/img/image-20210920200749163.82b898b6.png"},759:function(t,v,_){t.exports=_.p+"assets/img/image-20210920201511915.34fbd27d.png"},760:function(t,v,_){t.exports=_.p+"assets/img/image-20210920201607622.855ce948.png"},761:function(t,v,_){t.exports=_.p+"assets/img/image-20210920205204834.02e80f34.png"},762:function(t,v,_){t.exports=_.p+"assets/img/image-20210920210415629.2149f04b.png"},763:function(t,v,_){t.exports=_.p+"assets/img/image-20210921170748503.a05b339c.png"},764:function(t,v,_){t.exports=_.p+"assets/img/image-20210921170952360.5eb23c28.png"},765:function(t,v,_){t.exports=_.p+"assets/img/image-20210921182459387.d1c18df0.png"},766:function(t,v,_){t.exports=_.p+"assets/img/image-20210921182607681.90cd1c5c.png"},767:function(t,v,_){t.exports=_.p+"assets/img/image-20210922194824359.ec978f9d.png"},768:function(t,v,_){t.exports=_.p+"assets/img/image-20210922202343192.8544ae77.png"},769:function(t,v,_){t.exports=_.p+"assets/img/image-20210922202614387.700868dd.png"},770:function(t,v,_){t.exports=_.p+"assets/img/image-20210922212055730.75080ebb.png"},771:function(t,v,_){t.exports=_.p+"assets/img/image-20210922213531247.0f6edf18.png"},772:function(t,v,_){t.exports=_.p+"assets/img/image-20210922214050740.b1f27129.png"},773:function(t,v,_){t.exports=_.p+"assets/img/image-20210923183604269.fee262de.png"},774:function(t,v,_){t.exports=_.p+"assets/img/image-20210923183857637.2ceab718.png"},775:function(t,v,_){t.exports=_.p+"assets/img/image-20210923184124840.2e624ef0.png"},776:function(t,v,_){t.exports=_.p+"assets/img/image-20210923184406372.a5784c35.png"},777:function(t,v,_){t.exports=_.p+"assets/img/image-20210924115530265.e837045e.png"},778:function(t,v,_){t.exports=_.p+"assets/img/image-20210924120330827.dabb5a57.png"},779:function(t,v,_){t.exports=_.p+"assets/img/image-20210924121007282.9d46c2c9.png"},780:function(t,v,_){t.exports=_.p+"assets/img/image-20210924123213329.64f1a36c.png"},781:function(t,v,_){t.exports=_.p+"assets/img/image-20210924201548572.5028d357.png"},782:function(t,v,_){t.exports=_.p+"assets/img/image-20210925204209684.f33a1677.png"},783:function(t,v,_){t.exports=_.p+"assets/img/image-20210925204552483.3376ab1b.png"},784:function(t,v,_){t.exports=_.p+"assets/img/image-20210925213648467.f31b8df8.png"},785:function(t,v,_){t.exports=_.p+"assets/img/image-20210925214311284.42916d71.png"},786:function(t,v,_){t.exports=_.p+"assets/img/image-20210925214342893.12e47c81.png"},787:function(t,v,_){t.exports=_.p+"assets/img/image-20210929203802766.14dcda20.png"},788:function(t,v,_){t.exports=_.p+"assets/img/image-20211001171303661.13be1f43.png"},789:function(t,v,_){t.exports=_.p+"assets/img/image-20211001175605773.0939d45f.png"},790:function(t,v,_){t.exports=_.p+"assets/img/image-20211001194008665.077cc05b.png"},791:function(t,v,_){t.exports=_.p+"assets/img/image-20211001195444270.366927f1.png"},792:function(t,v,_){t.exports=_.p+"assets/img/image-20211001201942263.eb91eb03.png"},793:function(t,v,_){t.exports=_.p+"assets/img/image-20211001202221971.60f1f3e3.png"},794:function(t,v,_){t.exports=_.p+"assets/img/image-20211001202242286.3ad7861d.png"},795:function(t,v,_){t.exports=_.p+"assets/img/image-20211001204306195.9d185c28.png"},796:function(t,v,_){t.exports=_.p+"assets/img/image-20211002105525613.8ef74979.png"},797:function(t,v,_){t.exports=_.p+"assets/img/image-20211002105603116.a5f3e24d.png"},798:function(t,v,_){t.exports=_.p+"assets/img/image-20211002111618538.0e270e97.png"},799:function(t,v,_){t.exports=_.p+"assets/img/image-20211002114426185.1cac5dcf.png"},800:function(t,v,_){t.exports=_.p+"assets/img/image-20211002121635952.311aaf13.png"},801:function(t,v,_){t.exports=_.p+"assets/img/image-20211002171251122.2fa9c7cd.png"},802:function(t,v,_){t.exports=_.p+"assets/img/image-20211002175500028.9e2e6474.png"},803:function(t,v,_){t.exports=_.p+"assets/img/image-20211002180416674.08789f50.png"},804:function(t,v,_){t.exports=_.p+"assets/img/image-20211002191123931.744d28a3.png"},805:function(t,v,_){t.exports=_.p+"assets/img/image-20211002191611822.05aa064d.png"},806:function(t,v,_){t.exports=_.p+"assets/img/image-20211002192631317.d99bc5be.png"},807:function(t,v,_){t.exports=_.p+"assets/img/image-20211002192952272.5d3d7106.png"},808:function(t,v,_){t.exports=_.p+"assets/img/image-20211002194510268.97fff46b.png"},809:function(t,v,_){t.exports=_.p+"assets/img/image-20211002194943763.f12b9f77.png"},810:function(t,v,_){t.exports=_.p+"assets/img/image-20211002201819579.8c6c0c55.png"},811:function(t,v,_){t.exports=_.p+"assets/img/image-20211002202226147.d2677361.png"},812:function(t,v,_){t.exports=_.p+"assets/img/image-20211002202513602.bec6601b.png"},813:function(t,v,_){t.exports=_.p+"assets/img/image-20211002202009729.baa77370.png"},814:function(t,v,_){t.exports=_.p+"assets/img/image-20211002211121694.824633b3.png"},815:function(t,v,_){t.exports=_.p+"assets/img/image-20211002211543016.0f5bf08a.png"},816:function(t,v,_){t.exports=_.p+"assets/img/image-20211003173154934.ac881fa8.png"},817:function(t,v,_){t.exports=_.p+"assets/img/image-20211003173419937.78d8a7fe.png"},818:function(t,v,_){t.exports=_.p+"assets/img/image-20211003174925826.e0812460.png"},819:function(t,v,_){t.exports=_.p+"assets/img/image-20211003194942762.cebc9326.png"},836:function(t,v,_){"use strict";_.r(v);var a=_(17),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"第一章-导论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第一章-导论"}},[t._v("#")]),t._v(" 第一章 导论")]),t._v(" "),a("p",[t._v("本章目标")]),t._v(" "),a("p",[t._v("1、描述==计算机系统的基本组成==")]),t._v(" "),a("p",[t._v("2、概述"),a("strong",[t._v("计算机系统的主要组件")])]),t._v(" "),a("p",[t._v("3、概述"),a("strong",[t._v("多种类型的计算机环境")])]),t._v(" "),a("p",[t._v("4、探讨"),a("strong",[t._v("多个开源的操作系统")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("操作系统位于==计算机用户与计算机硬件之间，中介==")]),t._v(" "),a("p",[t._v("作用：")]),t._v(" "),a("p",[t._v("1、提供环境，以便用户执行程序")]),t._v(" "),a("p",[t._v("2、"),a("font",{attrs:{color:"red"}},[t._v("管理计算机硬件的程序")])],1),t._v(" "),a("p",[t._v("3、大型机主要优化"),a("font",{attrs:{color:"red"}},[t._v("硬件使用率")])],1),t._v(" "),a("h2",{attrs:{id:"操作系统的功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的功能"}},[t._v("#")]),t._v(" 操作系统的功能")]),t._v(" "),a("p",[t._v("计算机系统分为4个组件：==硬件、操作系统、应用程序、用户==（底层到顶层）")]),t._v(" "),a("p",[t._v("硬件："),a("strong",[t._v("CPU中央处理单元、内存、输入/输出设备")]),t._v("，为系统提供基本的计算机资源，"),a("font",{attrs:{color:"purple"}},[t._v("操作系统控制硬件")]),t._v("，并协调各个用户应用程序的硬件使用")],1),t._v(" "),a("p",[a("font",{attrs:{color:"orange"}},[t._v("操作系统类似政府")]),t._v("，本身不能实现任何有用的功能，而"),a("font",{attrs:{color:"green"}},[t._v("提供一个方便程序执行的环境")])],1),t._v(" "),a("h3",{attrs:{id:"操作系统的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的定义"}},[t._v("#")]),t._v(" 操作系统的定义")]),t._v(" "),a("p",[t._v("操作系统：==控制和分配I/O==（input、output输入输出设备）==设备资源的共同功能==被组成一个"),a("font",{attrs:{color:"red"}},[t._v("软件")]),t._v("模块")],1),t._v(" "),a("p",[t._v("公认的定义：==内核==")]),t._v(" "),a("h2",{attrs:{id:"计算机系统的组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机系统的组成"}},[t._v("#")]),t._v(" 计算机系统的组成")]),t._v(" "),a("p",[t._v("通过"),a("font",{attrs:{color:"red"}},[t._v("总线")]),t._v("相连接")],1),t._v(" "),a("p",[a("img",{attrs:{src:_(740),alt:"image-20210919173306318"}})]),t._v(" "),a("h3",{attrs:{id:"计算机系统的运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机系统的运行"}},[t._v("#")]),t._v(" 计算机系统的运行")]),t._v(" "),a("p",[t._v("计算机系统包括==一个或多个CPU和若干设备控制器，通过总线连接，总线提供共享内存的访问==")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("CPU与设备控制器可以并发执行")]),t._v("，竞争访问内存，此时需要"),a("font",{attrs:{color:"purple"}},[t._v("内存控制器")]),t._v("来协调")],1),t._v(" "),a("p",[t._v("==引导程序（只读内存ROM）==：开机时，初始操作系统，"),a("font",{attrs:{color:"green"}},[t._v("位于操作系统内核并加载到内存")]),t._v("，一旦内核加载到内存并执行，就开始为系统和用户提供服务")],1),t._v(" "),a("p",[a("font",{attrs:{color:"purple"}},[t._v("事件发生")]),t._v("：硬件（总线发送到CPU）和软件（系统调用）的中断来通知")],1),t._v(" "),a("h3",{attrs:{id:"存储结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储结构"}},[t._v("#")]),t._v(" 存储结构")]),t._v(" "),a("p",[a("img",{attrs:{src:_(741),alt:"image-20210919184751935"}})]),t._v(" "),a("p",[t._v("内存：随机访问内存（RAM），动态随机访问内存DRAM")]),t._v(" "),a("h3",{attrs:{id:"i-o结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o结构"}},[t._v("#")]),t._v(" I/O结构")]),t._v(" "),a("p",[t._v("操作系统为每个设备控制器提供一个==设备驱动程序==")]),t._v(" "),a("img",{attrs:{src:_(742),alt:"image-20210919184838712"}}),t._v(" "),a("h2",{attrs:{id:"计算机系统的体系结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算机系统的体系结构"}},[t._v("#")]),t._v(" 计算机系统的体系结构")]),t._v(" "),a("h3",{attrs:{id:"单处理器系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单处理器系统"}},[t._v("#")]),t._v(" 单处理器系统")]),t._v(" "),a("p",[t._v("只有一个CPU")]),t._v(" "),a("p",[t._v("==通用指令集==：可以执行用户进程，执行很大东西")]),t._v(" "),a("p",[t._v("==专用处理器==：特定设备的处理器，如磁盘、键盘、图形处理器（显示器）")]),t._v(" "),a("h3",{attrs:{id:"多处理器系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多处理器系统"}},[t._v("#")]),t._v(" 多处理器系统")]),t._v(" "),a("p",[t._v("多CPU，也称"),a("font",{attrs:{color:"red"}},[t._v("多核")])],1),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("p",[t._v("1、增加"),a("font",{attrs:{color:"red"}},[t._v("吞吐量")])],1),t._v(" "),a("p",[t._v("2、规模经济")]),t._v(" "),a("p",[t._v("3、增加可靠性（一个CPU坏不影响其他）")]),t._v(" "),a("p",[a("img",{attrs:{src:_(743),alt:"image-20210919195652501"}})]),t._v(" "),a("p",[t._v("非对称处理器：有各自特定的任务，==主从关系==，==主处理器==调度==从处理器==，并安排任务")]),t._v(" "),a("p",[t._v("对称处理器：没有主从关系")]),t._v(" "),a("h3",{attrs:{id:"集群系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群系统"}},[t._v("#")]),t._v(" 集群系统")]),t._v(" "),a("p",[t._v("将多个CPU组合，通过"),a("font",{attrs:{color:"red"}},[t._v("网络连接")]),t._v("，提供"),a("font",{attrs:{color:"red"}},[t._v("高可用性")]),t._v("的服务")],1),t._v(" "),a("p",[a("img",{attrs:{src:_(744),alt:"image-20210919202020157"}})]),t._v(" "),a("h2",{attrs:{id:"操作系统的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的结构"}},[t._v("#")]),t._v(" 操作系统的结构")]),t._v(" "),a("p",[t._v("具有"),a("font",{attrs:{color:"red"}},[t._v("多道程序")]),t._v("能力，运行多个程序，多道程序安排作业，==使得CPU总有一个作业，提高CPU利用率==")],1),t._v(" "),a("p",[t._v("由于内存太小不能存所有作业，首先存在==磁盘的作业池==上，作业即进程")]),t._v(" "),a("p",[a("img",{attrs:{src:_(745),alt:"image-20210919204200261"}})]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("分时系统")]),t._v("：确保响应时间，提高一个小部分的==分时==计算机资源，即==CPU切换到其他进程的时间==，CPU只能执行一个进程")],1),t._v(" "),a("h2",{attrs:{id:"操作系统的执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的执行"}},[t._v("#")]),t._v(" 操作系统的执行")]),t._v(" "),a("p",[t._v("软件-------------------------操作系统------------------------硬件")]),t._v(" "),a("p",[t._v("==操作系统==是==中断==驱动的，==事件==是中断或陷阱（或异常）引起的")]),t._v(" "),a("p",[t._v("陷阱（或异常）：软件生成的中断，"),a("font",{attrs:{color:"red"}},[t._v("用户请求")])],1),t._v(" "),a("h3",{attrs:{id:"双重模式与多重模式的执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双重模式与多重模式的执行"}},[t._v("#")]),t._v(" 双重模式与多重模式的执行")]),t._v(" "),a("p",[t._v("用户模式（1）和内核模式（0）：")]),t._v(" "),a("p",[t._v("1、==硬件==通过==模式位==表示当前模式")]),t._v(" "),a("p",[t._v("2、"),a("font",{attrs:{color:"red"}},[t._v("执行用户应用，用户模式，请求操作系统服务，内核模式")])],1),t._v(" "),a("p",[a("img",{attrs:{src:_(746),alt:"image-20210919211616166"}})]),t._v(" "),a("p",[t._v("双重模式==执行提供保护手段==，将可能引起==损害机器指令==作为"),a("font",{attrs:{color:"red"}},[t._v("特权指令")]),t._v("，在==内核模式下执行==，用户模式想执行硬件不理会")],1),t._v(" "),a("h3",{attrs:{id:"定时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[t._v("#")]),t._v(" 定时器")]),t._v(" "),a("p",[t._v("==操作系统维持控制CPU==，"),a("font",{attrs:{color:"red"}},[t._v("进程超过一定时间没响应")]),t._v("，则关闭，防止程序陷入死循环")],1),t._v(" "),a("h2",{attrs:{id:"进程管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程管理"}},[t._v("#")]),t._v(" 进程管理")]),t._v(" "),a("p",[t._v("==执行中的程序称为进程==，程序计数器（PC），有下一个指令的相关信息")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("进程是系统的工作单元")]),t._v("，其中有操作系统进程，也有用户进程，所有进程"),a("font",{attrs:{color:"red"}},[t._v("并发执行")])],1),t._v(" "),a("p",[t._v("操作系统负责进程管理的以下活动：")]),t._v(" "),a("p",[t._v("1、"),a("font",{attrs:{color:"red"}},[t._v("在CPU上调度")]),t._v("进程和线程")],1),t._v(" "),a("p",[t._v("2、"),a("font",{attrs:{color:"red"}},[t._v("创建和销毁")]),t._v("用户进程和系统进程")],1),t._v(" "),a("p",[t._v("3、"),a("font",{attrs:{color:"red"}},[t._v("挂起和重启")]),t._v("进程")],1),t._v(" "),a("p",[t._v("4、提供进程"),a("font",{attrs:{color:"red"}},[t._v("同步")]),t._v("机制")],1),t._v(" "),a("p",[t._v("5、提供进程"),a("font",{attrs:{color:"red"}},[t._v("通信")]),t._v("机制")],1),t._v(" "),a("h2",{attrs:{id:"内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),a("p",[t._v("如果==CPU执行指令==，那么这些数据首先通过==IO调度传到内存==，在内存中保留多个程序（多道程序）需要内存管理")]),t._v(" "),a("p",[t._v("操作系统负责内存管理的以下活动：")]),t._v(" "),a("p",[t._v("1、记录内存的"),a("font",{attrs:{color:"red"}},[t._v("哪部分被使用以及谁使用")])],1),t._v(" "),a("p",[t._v("2、决定哪些进程会"),a("font",{attrs:{color:"red"}},[t._v("调入或调出")]),t._v("内存")],1),t._v(" "),a("p",[t._v("3、根据需要"),a("font",{attrs:{color:"red"}},[t._v("分配和释放")]),t._v("内存空间")],1),t._v(" "),a("h2",{attrs:{id:"存储管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#存储管理"}},[t._v("#")]),t._v(" 存储管理")]),t._v(" "),a("p",[t._v("信息存储的==统一逻辑视图==")]),t._v(" "),a("p",[t._v("文件：操作系统==映射==文件到==物理媒介==，并通过==存储设备来访问文件==")]),t._v(" "),a("h3",{attrs:{id:"高速缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存"}},[t._v("#")]),t._v(" 高速缓存")]),t._v(" "),a("p",[a("img",{attrs:{src:_(747),alt:"image-20210919220923783"}})]),t._v(" "),a("p",[a("img",{attrs:{src:_(748),alt:"image-20210919221301434"}})]),t._v(" "),a("h3",{attrs:{id:"i-o系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#i-o系统"}},[t._v("#")]),t._v(" I/O系统")]),t._v(" "),a("p",[t._v("==IO子系统==为操作系统本身==隐藏IO设备的特性==，"),a("font",{attrs:{color:"red"}},[t._v("只有设备驱动程序才能知道")])],1),t._v(" "),a("p",[t._v("IO子系统包括以下几个组件：")]),t._v(" "),a("p",[t._v("1、"),a("font",{attrs:{color:"green"}},[t._v("缓冲、高速缓存和假脱机的内存管理组件")])],1),t._v(" "),a("p",[t._v("2、"),a("font",{attrs:{color:"green"}},[t._v("设备驱动器的通用接口")])],1),t._v(" "),a("p",[t._v("3、"),a("font",{attrs:{color:"green"}},[t._v("特定硬件设备的驱动程序")])],1),t._v(" "),a("h2",{attrs:{id:"保护与安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保护与安全"}},[t._v("#")]),t._v(" 保护与安全")]),t._v(" "),a("p",[t._v("保护：控制进程或用户访问计算机系统的资源，例==阻止用户对内核的非法调用==")]),t._v(" "),a("p",[t._v("安全：==防止系统受外部或内部攻击==")]),t._v(" "),a("h2",{attrs:{id:"计算环境"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算环境"}},[t._v("#")]),t._v(" 计算环境")]),t._v(" "),a("p",[t._v("操作系统如何用于各种计算环境")]),t._v(" "),a("h3",{attrs:{id:"分布计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布计算"}},[t._v("#")]),t._v(" 分布计算")]),t._v(" "),a("p",[t._v("分布式系统是==物理上分开的，通过网络相连==")]),t._v(" "),a("h3",{attrs:{id:"客户机-服务器计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户机-服务器计算"}},[t._v("#")]),t._v(" 客户机-服务器计算")]),t._v(" "),a("p",[t._v("client/server")]),t._v(" "),a("p",[a("img",{attrs:{src:_(749),alt:"image-20210920165829052"}})]),t._v(" "),a("h3",{attrs:{id:"对等计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对等计算"}},[t._v("#")]),t._v(" 对等计算")]),t._v(" "),a("p",[t._v("不区分客户机和服务器，每个节点都可以作为客户机或服务器")]),t._v(" "),a("p",[a("img",{attrs:{src:_(750),alt:"image-20210920170100313"}})]),t._v(" "),a("h3",{attrs:{id:"虚拟化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟化"}},[t._v("#")]),t._v(" 虚拟化")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("操作系统")]),t._v("可以在"),a("font",{attrs:{color:"red"}},[t._v("其他操作系统上运行应用程序")]),t._v("，如VMware软件、阿里云服务器等")],1),t._v(" "),a("p",[a("img",{attrs:{src:_(751),alt:"image-20210920170433227"}})]),t._v(" "),a("h3",{attrs:{id:"云计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#云计算"}},[t._v("#")]),t._v(" 云计算")]),t._v(" "),a("p",[t._v("==虚拟化技术的延伸==，一个显示屏，没有CPU，"),a("font",{attrs:{color:"red"}},[t._v("显示屏只是为了显示，所有计算操作都在远程的云上")])],1),t._v(" "),a("p",[t._v("云计算类型：")]),t._v(" "),a("p",[t._v("1、公有云")]),t._v(" "),a("p",[t._v("2、私有云")]),t._v(" "),a("p",[t._v("3、混合云")]),t._v(" "),a("p",[t._v("4、软件即服务（SaaS）")]),t._v(" "),a("p",[t._v("5、平台即服务（PaaS）")]),t._v(" "),a("p",[t._v("6、基础设施及服务（IaaS）")]),t._v(" "),a("p",[a("img",{attrs:{src:_(752),alt:"image-20210920170644021"}})]),t._v(" "),a("h3",{attrs:{id:"实时嵌入式系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实时嵌入式系统"}},[t._v("#")]),t._v(" 实时嵌入式系统")]),t._v(" "),a("p",[t._v("==嵌入式系统几乎总是采用实时操作系统==，单一，例：汽车、家电；不像计算机的操作系统要符合大多数情况")]),t._v(" "),a("h3",{attrs:{id:"开源操作系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开源操作系统"}},[t._v("#")]),t._v(" 开源操作系统")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("开放源代码")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("闭源")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("Linux、Unix")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("Windows")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("Google的Android")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("苹果的IOS")])])])]),t._v(" "),a("h1",{attrs:{id:"第二章-操作系统结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第二章-操作系统结构"}},[t._v("#")]),t._v(" 第二章 操作系统结构")]),t._v(" "),a("p",[t._v("本章目标")]),t._v(" "),a("p",[t._v("1、描述操作系统为==用户、进程和其他系统==提供的服务")]),t._v(" "),a("p",[t._v("2、讨论构建==操作系统的各种方式==")]),t._v(" "),a("p",[t._v("3、解释如何==安装与定制操作系统==以及如何==启动操作系统==")]),t._v(" "),a("h2",{attrs:{id:"操作系统的服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的服务"}},[t._v("#")]),t._v(" 操作系统的服务")]),t._v(" "),a("p",[t._v("1、==用户界面==："),a("font",{attrs:{color:"red"}},[t._v("命令行、图形用户")]),t._v("、批处理界面")],1),t._v(" "),a("p",[t._v("2、==程序执行==：加载程序到内存")]),t._v(" "),a("p",[t._v("3、通信：一个进程与另一个进程交换信息，例内存共享等")]),t._v(" "),a("p",[t._v("4、错误检测：检测和更正错误")]),t._v(" "),a("p",[t._v("5、==资源分配==：多个程序运行时，资源的分配")]),t._v(" "),a("p",[t._v("6、记账：记录用户使用资源的类型和数量")]),t._v(" "),a("p",[a("img",{attrs:{src:_(753),alt:"image-20210920175536363"}})]),t._v(" "),a("h2",{attrs:{id:"用户与操作系统的界面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户与操作系统的界面"}},[t._v("#")]),t._v(" 用户与操作系统的界面")]),t._v(" "),a("p",[t._v("主要：==命令==解释程序和==图形==用户界面")]),t._v(" "),a("h3",{attrs:{id:"命令解释程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令解释程序"}},[t._v("#")]),t._v(" 命令解释程序")]),t._v(" "),a("p",[t._v("==Shell（脚本）==：解释程序，"),a("font",{attrs:{color:"red"}},[t._v("命令转换为机器指令")])],1),t._v(" "),a("h3",{attrs:{id:"图形用户界面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#图形用户界面"}},[t._v("#")]),t._v(" 图形用户界面")]),t._v(" "),a("p",[t._v("优点：操作简单\t\t\t\t缺点：复杂度高，bug更多")]),t._v(" "),a("h2",{attrs:{id:"系统调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统调用"}},[t._v("#")]),t._v(" 系统调用")]),t._v(" "),a("p",[t._v("提供==操作系统服务接口==，通常开发人员根据==应用程序接口（API）==来设计程序")]),t._v(" "),a("p",[a("img",{attrs:{src:_(754),alt:"image-20210920182605130"}})]),t._v(" "),a("p",[t._v("例：一个简单的复制文件，可能需要n次系统API的调用")]),t._v(" "),a("p",[a("img",{attrs:{src:_(755),alt:"image-20210920182351818"}})]),t._v(" "),a("h2",{attrs:{id:"系统调用的类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统调用的类型"}},[t._v("#")]),t._v(" 系统调用的类型")]),t._v(" "),a("p",[t._v("大致分为六类：")]),t._v(" "),a("p",[t._v("1、进程控制")]),t._v(" "),a("p",[t._v("2、文件管理")]),t._v(" "),a("p",[t._v("3、设备管理")]),t._v(" "),a("p",[t._v("4、信息维护")]),t._v(" "),a("p",[t._v("5、通信")]),t._v(" "),a("p",[t._v("6、保护")]),t._v(" "),a("p",[a("img",{attrs:{src:_(756),alt:"image-20210920190836313"}})]),t._v(" "),a("h3",{attrs:{id:"进程控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制"}},[t._v("#")]),t._v(" 进程控制")]),t._v(" "),a("p",[t._v("例：")]),t._v(" "),a("p",[a("strong",[t._v("异常")]),t._v("停止当前执行的程序，那么可能转"),a("strong",[t._v("存储内存到磁盘")])]),t._v(" "),a("p",[a("strong",[t._v("多个进程共享数据，确保数据的完整性")]),t._v("（即只能一个使用完，下一个才能用），使用==锁定（lock==），解锁之前其他不能访问")]),t._v(" "),a("p",[a("img",{attrs:{src:_(757),alt:"image-20210920191614585"}})]),t._v(" "),a("h2",{attrs:{id:"操作系统的结构-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作系统的结构-2"}},[t._v("#")]),t._v(" 操作系统的结构")]),t._v(" "),a("p",[t._v("操作系统"),a("strong",[t._v("庞大且复杂")]),t._v("，所以分成==子系统或模块==")]),t._v(" "),a("h3",{attrs:{id:"分层方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分层方法"}},[t._v("#")]),t._v(" 分层方法")]),t._v(" "),a("p",[t._v("优点：==简化了构造和调试==，"),a("strong",[t._v("每层只能调用更底层的")]),t._v("功能和服务")]),t._v(" "),a("p",[a("img",{attrs:{src:_(758),alt:"image-20210920200749163"}})]),t._v(" "),a("h3",{attrs:{id:"微内核"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微内核"}},[t._v("#")]),t._v(" 微内核")]),t._v(" "),a("p",[t._v("==对内核进行模块化==，删除所有不必要的部件，将他们当作"),a("strong",[t._v("系统级与用户级的程序来实现")]),t._v("，使内核较小")]),t._v(" "),a("p",[t._v("主要功能：为客户端程序和运行在用户空间的各种服务==提供通信==")]),t._v(" "),a("p",[t._v("优点：内核更小、==便于扩展==、更好的安全性和可靠性、便于移植。")]),t._v(" "),a("p",[t._v("缺点：==性能会受损==，即来回切换模式")]),t._v(" "),a("h3",{attrs:{id:"模块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[t._v("#")]),t._v(" 模块")]),t._v(" "),a("p",[t._v("目前的操作系统采用==可加载的内核模块==，需要那个就加载到内核")]),t._v(" "),a("p",[a("img",{attrs:{src:_(759),alt:"image-20210920201511915"}})]),t._v(" "),a("h3",{attrs:{id:"混合系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#混合系统"}},[t._v("#")]),t._v(" 混合系统")]),t._v(" "),a("p",[a("img",{attrs:{src:_(760),alt:"image-20210920201607622"}})]),t._v(" "),a("h2",{attrs:{id:"系统引导"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统引导"}},[t._v("#")]),t._v(" 系统引导")]),t._v(" "),a("p",[t._v("操作系统如何启动？")]),t._v(" "),a("p",[t._v("系统引导：==加载内核==以启动计算机的过程")]),t._v(" "),a("p",[t._v("大多数计算机系统有一小块代码为==引导程序（只读存储器ROM）==，它能"),a("font",{attrs:{color:"red"}},[t._v("定位内核")]),t._v("，并"),a("font",{attrs:{color:"red"}},[t._v("加载到内存以开始执行")])],1),t._v(" "),a("h1",{attrs:{id:"第三章-进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第三章-进程"}},[t._v("#")]),t._v(" 第三章 进程")]),t._v(" "),a("p",[t._v("本章目标：")]),t._v(" "),a("p",[t._v("1、引入"),a("strong",[t._v("进程概念")]),t._v("，即执行的程序，这是所有计算的基础")]),t._v(" "),a("p",[t._v("2、讨论进程的"),a("strong",[t._v("各类特性，包括调度、创建和终止")])]),t._v(" "),a("p",[t._v("3、探讨通过"),a("strong",[t._v("共享内存和消息传递的进程间通信")])]),t._v(" "),a("p",[t._v("4、讨论"),a("strong",[t._v("客户机与服务器系统间的通信")])]),t._v(" "),a("hr"),t._v(" "),a("p",[t._v("==进程是执行中的程序==，是现代分时操作系统的==工作单元==，通过"),a("strong",[t._v("CPU")]),t._v("的"),a("strong",[t._v("多路复用")]),t._v("，所有==进程==可以==并发执行==")]),t._v(" "),a("h2",{attrs:{id:"进程概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程概念"}},[t._v("#")]),t._v(" 进程概念")]),t._v(" "),a("p",[t._v("CPU活动：执行作业（job）、任务（task）、程序")]),t._v(" "),a("h3",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),a("p",[a("strong",[t._v("程序本身不是进程")]),t._v("，==程序是被动实体==，如可执行文件（.exe），而==进程是活动实体==，一个可执行文件被加载到内存时，这个程序就成为进程，"),a("font",{attrs:{color:"red"}},[t._v("进程里包含线程")])],1),t._v(" "),a("p",[t._v("==进程是操作系统进行资源分配和调度的基本单位==，即工作单元")]),t._v(" "),a("p",[a("img",{attrs:{src:_(761),alt:"image-20210920205204834"}})]),t._v(" "),a("h3",{attrs:{id:"进程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程状态"}},[t._v("#")]),t._v(" 进程状态")]),t._v(" "),a("p",[t._v("每个进程可能处于以下状态：")]),t._v(" "),a("p",[t._v("1、新的（new）：进程创建")]),t._v(" "),a("p",[t._v("2、运行（running）：正在执行")]),t._v(" "),a("p",[t._v("3、等待（waiting）：阻塞状态，进程等待发生某个事件（如IO完成），即"),a("strong",[t._v("某一时刻要打印，向等待IO设备的连接，连接成功后进入就绪，最后运行")])]),t._v(" "),a("p",[t._v("4、就绪（ready）：进程等待分配处理器")]),t._v(" "),a("p",[t._v("5、终止（terminated）：进程结束")]),t._v(" "),a("p",[a("img",{attrs:{src:_(762),alt:"image-20210920210415629"}})]),t._v(" "),a("h3",{attrs:{id:"进程控制块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程控制块"}},[t._v("#")]),t._v(" 进程控制块")]),t._v(" "),a("p",[t._v("每个进程采用"),a("font",{attrs:{color:"red"}},[t._v("进程控制块（PCB）")]),t._v("来表示，信息的仓库，==PCB底层是双向链表==")],1),t._v(" "),a("p",[a("img",{attrs:{src:_(763),alt:"image-20210921170748503"}})]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("进程间的切换：实际是PCB之间的切换")])],1),t._v(" "),a("p",[a("img",{attrs:{src:_(764),alt:"image-20210921170952360"}})]),t._v(" "),a("h2",{attrs:{id:"进程调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程调度"}},[t._v("#")]),t._v(" 进程调度")]),t._v(" "),a("p",[t._v("1、多道程序：提高"),a("font",{attrs:{color:"red"}},[t._v("CPU利用率")])],1),t._v(" "),a("p",[t._v("2、分时系统：快速"),a("font",{attrs:{color:"red"}},[t._v("切换CPU")])],1),t._v(" "),a("p",[t._v("3、进程调度器："),a("font",{attrs:{color:"red"}},[t._v("选择一个可用进程到CPU上执行")])],1),t._v(" "),a("h3",{attrs:{id:"调度队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度队列"}},[t._v("#")]),t._v(" 调度队列")]),t._v(" "),a("p",[t._v("就绪队列：==等待运行==的进程")]),t._v(" "),a("p",[t._v("设备列表：==等待IO设备==的进程")]),t._v(" "),a("p",[a("img",{attrs:{src:_(765),alt:"image-20210921182459387"}})]),t._v(" "),a("h3",{attrs:{id:"调度程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度程序"}},[t._v("#")]),t._v(" 调度程序")]),t._v(" "),a("p",[t._v("操作系统通过调度程序来选择进程")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("长")]),t._v("期调度程序：放在"),a("font",{attrs:{color:"red"}},[t._v("缓冲池（磁盘）")]),t._v("中")],1),t._v(" "),a("li",[a("strong",[t._v("中")]),t._v("期：放在作业池中，进程可以"),a("font",{attrs:{color:"red"}},[t._v("换出，换入")])],1),t._v(" "),a("li",[a("strong",[t._v("短")]),t._v("期：在等待状态")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(766),alt:"image-20210921182607681"}})]),t._v(" "),a("ol",[a("li",[t._v("IO密集型进程：IO占用更多的时间")]),t._v(" "),a("li",[t._v("CPU密集型进程：CPU计算占用更多时间")])]),t._v(" "),a("h3",{attrs:{id:"上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#上下文切换"}},[t._v("#")]),t._v(" 上下文切换")]),t._v(" "),a("ul",[a("li",[t._v("==中断：系统保存进程的上下文，以便处理后恢复==")]),t._v(" "),a("li",[t._v("==进程上下文采用进程PCB表示==")]),t._v(" "),a("li",[t._v("==切换的时间是纯粹的开销，CPU在此期间是空闲的==")])]),t._v(" "),a("h2",{attrs:{id:"进程运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程运行"}},[t._v("#")]),t._v(" 进程运行")]),t._v(" "),a("p",[t._v("大多数系统的==进程能够并发执行，动态创建和删除，==")]),t._v(" "),a("h3",{attrs:{id:"进程创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程创建"}},[t._v("#")]),t._v(" 进程创建")]),t._v(" "),a("p",[t._v("对进程识别采用"),a("font",{attrs:{color:"red"}},[t._v("唯一的进程标识符（pid）")]),t._v("，是一个整数值，通过"),a("font",{attrs:{color:"red"}},[t._v("pid可以访问内核中进程的各种属性")])],1),t._v(" "),a("p",[a("strong",[t._v("创建新进程时，两种执行可能：")])]),t._v(" "),a("ul",[a("li",[t._v("==父和子进程并发执行==")]),t._v(" "),a("li",[t._v("==父进程等待==，直到子进程执行完成")])]),t._v(" "),a("p",[a("strong",[t._v("新进程的地址空间")]),t._v("也有两种可能：")]),t._v(" "),a("ul",[a("li",[t._v("具有与父进程==同样的程序和数据==")]),t._v(" "),a("li",[t._v("==加载另一个新程序==")])]),t._v(" "),a("h3",{attrs:{id:"进程终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程终止"}},[t._v("#")]),t._v(" 进程终止")]),t._v(" "),a("p",[t._v("进程终止时，操作系统会释放其资源")]),t._v(" "),a("p",[a("strong",[t._v("父进程终止子进程")]),t._v("的原因：")]),t._v(" "),a("ol",[a("li",[t._v("子进程使用==超过它所分配的资源==")]),t._v(" "),a("li",[t._v("分配给子进程的==任务不再需要==")]),t._v(" "),a("li",[t._v("==父进程退出==，不允许子进程在无父进程时执行")])]),t._v(" "),a("p",[t._v("==级联终止==："),a("font",{attrs:{color:"red"}},[t._v("一个进程终止，所有其对应的子进程也终止")]),t._v("，对应诛杀九族")],1),t._v(" "),a("h2",{attrs:{id:"进程间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信"}},[t._v("#")]),t._v(" 进程间通信")]),t._v(" "),a("p",[t._v("==并发执行进程==可以是==独立的也可以是协作的==")]),t._v(" "),a("p",[t._v("允许协作的==理由==：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("信息共享")])]),t._v(" "),a("li",[a("strong",[t._v("计算加速")])]),t._v(" "),a("li",[a("strong",[t._v("模块化")])])]),t._v(" "),a("p",[t._v("协作需要一种"),a("font",{attrs:{color:"red"}},[t._v("进程间通信机制")]),t._v("：两种基本模型（==内存共享和消息传递==）")],1),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("共享内存")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("消息传递")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("font",{attrs:{color:"red"}},[t._v("建立共享内存区域")])],1),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("直接通信："),a("font",{attrs:{color:"red"}},[t._v("明确通信的接收者和发送者")])],1)]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("确保它们"),a("strong",[t._v("不向同一位置写入数据")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("间接通信"),a("font",{attrs:{color:"red"}},[t._v("：通过邮箱或端口来发送或接收")])],1)]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("font",{attrs:{color:"red"}},[t._v("生产者进程--缓冲区（存储共享数据）--消费者进程")])],1),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("==阻塞和非阻塞（即消息和进程能不能同时）==")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("无界缓冲区，缓冲区为空，消费者需要等待")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("阻塞：发送进程阻塞，接收进程阻塞")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("有界，"),a("strong",[t._v("缓冲区为空，消费者等待，缓冲区满了，生产者等待")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("非阻塞：发送进程发送消息，接收进程接收消息")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(767),alt:"image-20210922194824359"}})]),t._v(" "),a("h2",{attrs:{id:"客户机-服务器通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户机-服务器通信"}},[t._v("#")]),t._v(" 客户机/服务器通信")]),t._v(" "),a("ul",[a("li",[t._v("socket（套接字）")]),t._v(" "),a("li",[t._v("远程过程调用RPC")]),t._v(" "),a("li",[t._v("管道")])]),t._v(" "),a("h3",{attrs:{id:"套接字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#套接字"}},[t._v("#")]),t._v(" 套接字")]),t._v(" "),a("p",[t._v("每个进程各有一个套接字，每个==socket由ip和端口组成==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(768),alt:"image-20210922202343192"}})]),t._v(" "),a("p",[t._v("缺点：低级形式通信，"),a("font",{attrs:{color:"red"}},[t._v("只允许交换无结构的字节流，C/S需要加上数据结构")])],1),t._v(" "),a("h3",{attrs:{id:"远程过程调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#远程过程调用"}},[t._v("#")]),t._v(" 远程过程调用")]),t._v(" "),a("p",[t._v("==通过网络来通信==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(769),alt:"image-20210922202614387"}})]),t._v(" "),a("h3",{attrs:{id:"管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#管道"}},[t._v("#")]),t._v(" 管道")]),t._v(" "),a("p",[t._v("实现管道，考虑四个问题：")]),t._v(" "),a("ol",[a("li",[a("font",{attrs:{color:"red"}},[t._v("单向通信还是双向通信")])],1),t._v(" "),a("li",[t._v("==双向通信时==，"),a("font",{attrs:{color:"red"}},[t._v("是半双工（数据在同一时间只能按一个方向传输）还是全双工")]),t._v("（两个方向都可以传输）")],1),t._v(" "),a("li",[t._v("通信进程之间"),a("font",{attrs:{color:"red"}},[t._v("是否有关系（父子）")])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("是否通过网络")]),t._v("，还是在同一台机器上")],1)]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("普通管道")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("命名管道")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("生产者-消费者")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("多个进程都可以用它")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("==通信时才存在==")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("==通信结束后继续存在==")])])])]),t._v(" "),a("h1",{attrs:{id:"第四章-多线程编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第四章-多线程编程"}},[t._v("#")]),t._v(" 第四章 多线程编程")]),t._v(" "),a("p",[t._v("现在大多数是"),a("strong",[t._v("一个进程包含多个线程")])]),t._v(" "),a("p",[a("strong",[t._v("本章目标")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("引入线程概念，即==CPU使用的基本单元==，构成==多线程计算机系统的基础==")]),t._v(" "),a("li",[t._v("讨论==多线程编程==的相关问题")])]),t._v(" "),a("h2",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("每个线程是CPU使用的一个基本单元")]),t._v("，"),a("strong",[t._v("进程是系统的工作单元")]),t._v(","),a("strong",[t._v("同一个进程")]),t._v("的其他"),a("font",{attrs:{color:"red"}},[t._v("线程共享代码段、数据段和其他操作系统资源")])],1),t._v(" "),a("p",[a("img",{attrs:{src:_(770),alt:"image-20210922212055730"}})]),t._v(" "),a("h3",{attrs:{id:"动机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动机"}},[t._v("#")]),t._v(" 动机")]),t._v(" "),a("p",[t._v("为什么创建多个线程？")]),t._v(" "),a("ul",[a("li",[t._v("操作系统==创建==多个进程比一个进程创建多个线程的"),a("strong",[t._v("开销大")])]),t._v(" "),a("li",[t._v("进程间==通信==和线程间通信更==复杂==")])]),t._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),a("ul",[a("li",[t._v("响应式：==部分阻塞==或执行冗余操作，==其他可以继续执行==，增加对用户的响应程度")]),t._v(" "),a("li",[t._v("资源共享：进程共享通过内存和消息传递等技术，而==线程默认共享进程里的资源==")]),t._v(" "),a("li",[t._v("经济：进程==创建非常昂贵==")]),t._v(" "),a("li",[t._v("可伸缩性：线程可在==多处理器核上并行运行==")])]),t._v(" "),a("h2",{attrs:{id:"多核编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多核编程"}},[t._v("#")]),t._v(" 多核编程")]),t._v(" "),a("p",[t._v("==改进并发性，成为并行性==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(771),alt:"image-20210922213531247"}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("并行性")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("并发性")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("串行性")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("多核，==多个进程同时进行==")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("==CPU上下文切换==，一个核，假象的并行性")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("不用切换，==一个线程执行完，下一个接着==")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(772),alt:"image-20210922214050740"}})]),t._v(" "),a("p",[t._v("Java中的高并发编程"),a("font",{attrs:{color:"red"}},[t._v("：一个线程睡眠，进程里的线程可能轮不到它执行，而执行了其他进程里的线程")])],1),t._v(" "),a("h2",{attrs:{id:"多线程模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多线程模型"}},[t._v("#")]),t._v(" 多线程模型")]),t._v(" "),a("p",[t._v("两种方法"),a("font",{attrs:{color:"red"}},[t._v("提供线程支持")]),t._v("：")],1),t._v(" "),a("p",[t._v("用户层的==用户线程==：位于内核之上，"),a("font",{attrs:{color:"red"}},[t._v("无需内核支持")])],1),t._v(" "),a("p",[t._v("内核层的==内核线程==：操作系统来支持与管理")]),t._v(" "),a("h3",{attrs:{id:"多对一模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多对一模型"}},[t._v("#")]),t._v(" 多对一模型")]),t._v(" "),a("p",[t._v("缺点：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("一个线程阻塞")]),t._v("，"),a("font",{attrs:{color:"red"}},[t._v("整个进程阻塞")])],1),t._v(" "),a("li",[t._v("多个线程"),a("font",{attrs:{color:"red"}},[t._v("不能并行运行在多处理核系统")])],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(773),alt:"image-20210923183604269"}})]),t._v(" "),a("h3",{attrs:{id:"一对一模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一对一模型"}},[t._v("#")]),t._v(" 一对一模型")]),t._v(" "),a("ul",[a("li",[a("font",{attrs:{color:"red"}},[t._v("允许多个线程并行运行在多处理器上")])],1),t._v(" "),a("li",[t._v("缺点：创建一个线程就创建一个内核线程，开销会影响性能")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(774),alt:"image-20210923183857637"}})]),t._v(" "),a("h3",{attrs:{id:"多对多模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多对多模型"}},[t._v("#")]),t._v(" 多对多模型")]),t._v(" "),a("p",[a("strong",[t._v("多路复用")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("==内核比用户线程少或者相等==")]),t._v(" "),a("li",[t._v("一个线程阻塞，内核可以调用另一个线程来执行，==可以多处理器并行执行==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(775),alt:"image-20210923184124840"}})]),t._v(" "),a("p",[a("strong",[t._v("双层模型")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("多对多的变种，==可以多路复用，也可以一对一==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(776),alt:"image-20210923184406372"}})]),t._v(" "),a("h2",{attrs:{id:"线程库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程库"}},[t._v("#")]),t._v(" 线程库")]),t._v(" "),a("p",[t._v("为程序员==提供创建和管理线程的API==")]),t._v(" "),a("h2",{attrs:{id:"线程池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[t._v("#")]),t._v(" 线程池")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("线程加载到池中等待工作")])],1),t._v(" "),a("p",[t._v("优点：")]),t._v(" "),a("ul",[a("li",[t._v("比等待创建一个线程快，因为存在")]),t._v(" "),a("li",[t._v("限制创建线程数量")]),t._v(" "),a("li",[t._v("将执行任务从创建任务的机制中分离出来")])]),t._v(" "),a("h1",{attrs:{id:"第五章-进程调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第五章-进程调度"}},[t._v("#")]),t._v(" 第五章 进程调度")]),t._v(" "),a("p",[a("strong",[t._v("本章目标")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("==引入CPU调度，是多道程序操作系统的基础==")]),t._v(" "),a("li",[t._v("描述"),a("font",{attrs:{color:"red"}},[t._v("各种CPU调度算法")])],1),t._v(" "),a("li",[t._v("讨论特定系统选择CPU调度算法的"),a("font",{attrs:{color:"red"}},[t._v("评估标准")])],1),t._v(" "),a("li",[t._v("分析多个操作系统的调度算法")])]),t._v(" "),a("h2",{attrs:{id:"基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("p",[t._v("多道程序：最大化CPU利用率")]),t._v(" "),a("p",[t._v("操作系统选择==进程==，并交给CPU执行")]),t._v(" "),a("h3",{attrs:{id:"cpu、i-o执行周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu、i-o执行周期"}},[t._v("#")]),t._v(" CPU、I/O执行周期")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("进程在这两个状态之间不断交替")])],1),t._v(" "),a("p",[t._v("IO密集型进程 & CPU密集型进程：==主要看谁出现次数最多，就是谁==")]),t._v(" "),a("h3",{attrs:{id:"cpu调度程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu调度程序"}},[t._v("#")]),t._v(" CPU调度程序")]),t._v(" "),a("p",[t._v("每当CPU空闲时，操作系统从就绪队列中选择一个进程来执行，"),a("font",{attrs:{color:"green"}},[t._v("PCB记录进程的情况")])],1),t._v(" "),a("h3",{attrs:{id:"抢占调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抢占调度"}},[t._v("#")]),t._v(" 抢占调度")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("CPU调度情况分为4种")]),t._v("：")],1),t._v(" "),a("ol",[a("li",[t._v("运行---等待（IO请求）")]),t._v(" "),a("li",[t._v("运行---就绪（中断）")]),t._v(" "),a("li",[t._v("等待---就绪（IO设备好了）")]),t._v(" "),a("li",[t._v("终止")])]),t._v(" "),a("p",[a("strong",[t._v("非抢占调度")]),t._v("，一个进程分配到CPU，"),a("font",{attrs:{color:"red"}},[t._v("该进程一直使用该CPU，直到它终止或切换到等待")])],1),t._v(" "),a("h3",{attrs:{id:"调度程序-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度程序-2"}},[t._v("#")]),t._v(" 调度程序")]),t._v(" "),a("p",[t._v("==将CPU控制权交给短期调度程序==选择的进程")]),t._v(" "),a("p",[t._v("功能：")]),t._v(" "),a("ul",[a("li",[t._v("切换上下文")]),t._v(" "),a("li",[t._v("切换到用户模式")]),t._v(" "),a("li",[t._v("跳转到用户程序的合适位置，以便重启程序")])]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("调度延迟")]),t._v("："),a("strong",[t._v("停止一个进程到启动另一个所需的时间")])],1),t._v(" "),a("h2",{attrs:{id:"调度准则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度准则"}},[t._v("#")]),t._v(" 调度准则")]),t._v(" "),a("p",[t._v("==最大化CPU使用率和吞吐量；==")]),t._v(" "),a("p",[t._v("==最小化周转时间、等待时间和响应时间==")]),t._v(" "),a("p",[t._v("方法：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("CPU使用率")]),t._v("："),a("font",{attrs:{color:"red"}},[t._v("40%（轻负荷）~90%（重负荷）")])],1),t._v(" "),a("li",[a("strong",[t._v("吞吐量")]),t._v("：单位时间内进程完成的数量")]),t._v(" "),a("li",[a("strong",[t._v("周转时间")]),t._v("："),a("font",{attrs:{color:"red"}},[t._v("所有时间段之和")]),t._v("，包括：CPU、IO执行；就绪等待时间；等待时间")],1),t._v(" "),a("li",[a("strong",[t._v("等待时间")]),t._v("："),a("font",{attrs:{color:"red"}},[t._v("就绪等待所花时间之和")])],1),t._v(" "),a("li",[a("strong",[t._v("响应时间")]),t._v("：提交请求到产生第一响应的时间")])]),t._v(" "),a("h2",{attrs:{id:"调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[t._v("#")]),t._v(" 调度算法")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("从就绪队列中选择进程以便为其分配CPU")])],1),t._v(" "),a("h3",{attrs:{id:"先到先服务调度-fcfs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先到先服务调度-fcfs"}},[t._v("#")]),t._v(" 先到先服务调度（FCFS）")]),t._v(" "),a("p",[t._v("==FCFS==：FIFO队列容易实现该算法，即==先请求CPU的进程首先分配到CPU==")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("优点：算法实现简单")])]),t._v(" "),a("li",[a("strong",[t._v("缺点：平均等待时间往往很长")]),t._v("，"),a("strong",[t._v("非抢占的")]),t._v("，进程一直使用该分配的CPU，直到释放")])]),t._v(" "),a("h3",{attrs:{id:"最短作业优先调度-sjf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最短作业优先调度-sjf"}},[t._v("#")]),t._v(" 最短作业优先调度（SJF）")]),t._v(" "),a("p",[t._v("也叫最短下次CPU执行算法，"),a("font",{attrs:{color:"red"}},[t._v("调度取决于进程的下次CPU执行的长度")])],1),t._v(" "),a("ul",[a("li",[a("strong",[t._v("优点：是最优的，平均等待时间最小")])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(777),alt:"image-20210924115530265"}})]),t._v(" "),a("p",[t._v("问题：如何知道下次CPU执行的长度？")]),t._v(" "),a("ul",[a("li",[t._v("对于"),a("strong",[t._v("批处理系统的长期调度")]),t._v("，可以将用户提交作业时"),a("font",{attrs:{color:"red"}},[t._v("指定的进程时限作为长度")])],1),t._v(" "),a("li",[t._v("短期调度：使用预测下次CPU执行长度，==认为下次CPU执行长度与以前的类似==")])]),t._v(" "),a("p",[t._v("SJF算法可以是抢占式或非抢占式，"),a("font",{attrs:{color:"red"}},[t._v("抢占式抢占当前运行进程（最短剩余时间优先调度）")])],1),t._v(" "),a("p",[a("img",{attrs:{src:_(778),alt:"image-20210924120330827"}})]),t._v(" "),a("h3",{attrs:{id:"优先级调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先级调度"}},[t._v("#")]),t._v(" 优先级调度")]),t._v(" "),a("ul",[a("li",[t._v("==按照优先级分配CPU==")]),t._v(" "),a("li",[t._v("可以是抢占的或非抢占的")]),t._v(" "),a("li",[t._v("导致问题是"),a("font",{attrs:{color:"red"}},[t._v("无穷阻塞或饥饿")]),t._v("，即优先级太低，而"),a("strong",[t._v("其他进来的进程比它高，一直在等待")]),t._v("，解决方法："),a("font",{attrs:{color:"red"}},[t._v("老化")]),t._v("，即长时间没有分配CPU，则"),a("strong",[t._v("把它优先级调高")])],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(779),alt:"image-20210924121007282"}})]),t._v(" "),a("h3",{attrs:{id:"轮转调度-rr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轮转调度-rr"}},[t._v("#")]),t._v(" 轮转调度（RR）")]),t._v(" "),a("ul",[a("li",[t._v("专门为"),a("strong",[t._v("分时系统设计类似于FCFS（先进先服务）")]),t._v("，==但增加了抢占以切换进程==")]),t._v(" "),a("li",[a("strong",[t._v("时间片到，中断操作系统，进行上下文切换")])]),t._v(" "),a("li",[t._v("==平均等待时间通常较长==")]),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("抢占式")]),t._v("，时间片到则抢占")],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(780),alt:"image-20210924123213329"}})]),t._v(" "),a("h3",{attrs:{id:"多级队列调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多级队列调度"}},[t._v("#")]),t._v(" 多级队列调度")]),t._v(" "),a("p",[t._v("将==就绪队列分成多个单独队列==，队列"),a("font",{attrs:{color:"red"}},[t._v("有自己的调度算法")]),t._v("，根据"),a("strong",[t._v("内存")]),t._v("大小、进程"),a("strong",[t._v("优先级")]),t._v("、"),a("strong",[t._v("进程类型")]),t._v("等划分单独队列")],1),t._v(" "),a("ul",[a("li",[a("strong",[t._v("优点：优先级高的进程优先执行")])]),t._v(" "),a("li",[a("strong",[t._v("缺点：存在饥饿问题")])]),t._v(" "),a("li",[a("img",{attrs:{src:_(781),alt:"image-20210924201548572"}})])]),t._v(" "),a("h3",{attrs:{id:"多级反馈队列调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多级反馈队列调度"}},[t._v("#")]),t._v(" 多级反馈队列调度")]),t._v(" "),a("p",[t._v("允许进程在队列之间迁移，==如果进程使用过多的CPU时间，迁到更低的优先级队列==")]),t._v(" "),a("p",[t._v("将"),a("font",{attrs:{color:"red"}},[t._v("IO密集型放在更高优先级")]),t._v("，因为"),a("font",{attrs:{color:"red"}},[t._v("IO得等待IO设备")]),t._v("，这样低的优先级也能有机会执行，"),a("font",{attrs:{color:"red"}},[t._v("防止饥饿")])],1),t._v(" "),a("h2",{attrs:{id:"多处理器调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多处理器调度"}},[t._v("#")]),t._v(" 多处理器调度")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("多个CPU")]),t._v("，则可以"),a("font",{attrs:{color:"red"}},[t._v("负载分配")])],1),t._v(" "),a("h3",{attrs:{id:"多处理器调度的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多处理器调度的方法"}},[t._v("#")]),t._v(" 多处理器调度的方法")]),t._v(" "),a("ul",[a("li",[t._v("多处理器系统："),a("font",{attrs:{color:"red"}},[t._v("一个处理器")]),t._v("处理所有调度决定、IO处理以及其他系统活动"),a("font",{attrs:{color:"red"}},[t._v("，其他处理器只执行用户代码")])],1),t._v(" "),a("li",[t._v("==多对称处理（SMP）==：每个处理器自我调度")])]),t._v(" "),a("h3",{attrs:{id:"处理器亲和性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理器亲和性"}},[t._v("#")]),t._v(" 处理器亲和性")]),t._v(" "),a("p",[t._v("让一个进程运行在同一个处理器上，即==切换进程时，CPU不变==，即一个进程对它运行的处理器具有亲和性")]),t._v(" "),a("ul",[a("li",[t._v("软亲和性：进程也可迁移到其他处理器上")]),t._v(" "),a("li",[t._v("硬亲和性：允许进程运行在某个处理器子集上")])]),t._v(" "),a("h3",{attrs:{id:"负载平衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载平衡"}},[t._v("#")]),t._v(" 负载平衡")]),t._v(" "),a("p",[t._v("==将负载平均分配到SMP系统的所有处理器==，抵消处理器亲和性的好处，并行实现")]),t._v(" "),a("p",[t._v("两种方法：")]),t._v(" "),a("ul",[a("li",[t._v("推迁移：将"),a("strong",[t._v("超载处理器")]),t._v("==推到==（push）"),a("strong",[t._v("不太忙的处理器")])]),t._v(" "),a("li",[t._v("拉迁移："),a("strong",[t._v("不太忙")]),t._v("的处理器拉"),a("strong",[t._v("忙的")]),t._v("处理器的进程")])]),t._v(" "),a("h2",{attrs:{id:"实时cpu调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实时cpu调度"}},[t._v("#")]),t._v(" 实时CPU调度")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("软实时系统：不保证调度关键实时进程，"),a("font",{attrs:{color:"red"}},[t._v("只保证优先于非关键进程")])],1)]),t._v(" "),a("li",[a("p",[t._v("硬实时系统："),a("font",{attrs:{color:"red"}},[t._v("截止期限之前完成，之后完成的不算")])],1)])]),t._v(" "),a("h3",{attrs:{id:"最小化延迟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小化延迟"}},[t._v("#")]),t._v(" 最小化延迟")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("中断延时：")])])]),t._v(" "),a("p",[t._v("中断发生，操作系统会完成正在执行的指令，再确定==中断类型==，然后==保存当前进程的状态==，采用中断服务程序==（ISR）==，这些需要的时间为中断延时")]),t._v(" "),a("p",[a("img",{attrs:{src:_(782),alt:"image-20210925204209684"}})]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[a("strong",[t._v("调度延时：")])])]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("停止一个进程到启动另一个进程所需时间")]),t._v("，降低时间方法：==抢占式内核==")],1),t._v(" "),a("p",[t._v("调度延迟的冲突有两部分：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("抢占其他进程")])]),t._v(" "),a("li",[a("strong",[t._v("释放进程占有的资源")])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(783),alt:"image-20210925204552483"}})]),t._v(" "),a("h3",{attrs:{id:"优先权调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先权调度"}},[t._v("#")]),t._v(" 优先权调度")]),t._v(" "),a("p",[t._v("实时操作系统的调度程序==支持抢占的、基于优先权的算法==，"),a("strong",[t._v("仅保证软实时")]),t._v("功能")]),t._v(" "),a("p",[t._v("调度进程的特性：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("周期性p")])]),t._v(" "),a("li",[a("strong",[t._v("处理时间t")])]),t._v(" "),a("li",[a("strong",[t._v("CPU截止期限d")])]),t._v(" "),a("li",[a("strong",[t._v("速率1/p")])]),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("关系：0<=t<=d<=p")])],1)]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("硬实时：如果任务不能在截止期限完成，拒绝请求")])],1),t._v(" "),a("h3",{attrs:{id:"单调速率调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单调速率调度"}},[t._v("#")]),t._v(" 单调速率调度")]),t._v(" "),a("p",[t._v("采用==抢占的、静态优先级==的策略，==周期越短，优先级越高==")]),t._v(" "),a("p",[t._v("例：两个进程P1和P2，P1和P2的"),a("strong",[t._v("周期")]),t._v("分别为50和100，P1和P2的"),a("strong",[t._v("处理时间")]),t._v("分别为t1=20和t2=35.每个进程的"),a("strong",[t._v("截止期限")]),t._v("要求在下一个周期开始之前完成CPU执行，"),a("font",{attrs:{color:"red"}},[t._v("周期比率t/p（CPU利用率）")])],1),t._v(" "),a("ul",[a("li",[t._v("==假设P2优先级比P1高，P1错过其截止期限==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(784),alt:"image-20210925213648467"}})]),t._v(" "),a("ul",[a("li",[t._v("==使用单调速率调度，P1优先级高于P2，因为其周期短==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(785),alt:"image-20210925214311284"}})]),t._v(" "),a("ul",[a("li",[t._v("==进程数量接近无穷时，CPU利用率接近69%，两个进程的CPU利用率是83%==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(786),alt:"image-20210925214342893"}})]),t._v(" "),a("h3",{attrs:{id:"最早截止期限优先调度-earliest-deadline-first-edf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最早截止期限优先调度-earliest-deadline-first-edf"}},[t._v("#")]),t._v(" 最早截止期限优先调度（Earliest-Deadline-First EDF）")]),t._v(" "),a("ul",[a("li",[t._v("动态分配优先级，==截止期限越早，优先级越高==")]),t._v(" "),a("li",[t._v("一个进程可运行时，"),a("font",{attrs:{color:"red"}},[t._v("向系统公布截止期限要求")])],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(787),alt:"image-20210929203802766"}})]),t._v(" "),a("ul",[a("li",[t._v("EDF调度不要求进程应是周期的")])]),t._v(" "),a("h3",{attrs:{id:"比例分享调度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#比例分享调度"}},[t._v("#")]),t._v(" 比例分享调度")]),t._v(" "),a("ul",[a("li",[t._v("调度程序在==所有应用之间分配T股==，A分配50股，B分配15股，C分配20股，剩余15股")]),t._v(" "),a("li",[t._v("准入控制策略："),a("strong",[t._v("如果新进程D请求30股，拒绝D")])])]),t._v(" "),a("h1",{attrs:{id:"第六章-同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第六章-同步"}},[t._v("#")]),t._v(" 第六章 同步")]),t._v(" "),a("p",[t._v("==协作进程==能与系统内的"),a("font",{attrs:{color:"red"}},[t._v("其他进程")]),t._v("相互影响，"),a("font",{attrs:{color:"red"}},[t._v("共享数据的并发访问可能导致数据的不一致")]),t._v("，所以要维护数据的一致性")],1),t._v(" "),a("p",[a("strong",[t._v("本章目标")])]),t._v(" "),a("ul",[a("li",[t._v("引入"),a("font",{attrs:{color:"red"}},[t._v("临界区问题，可以确保共享数据的一致性")])],1),t._v(" "),a("li",[t._v("临界区问题的"),a("strong",[t._v("软件和硬件解决方案")])]),t._v(" "),a("li",[t._v("分析"),a("strong",[t._v("进程同步的多个经典问题")])]),t._v(" "),a("li",[t._v("探讨"),a("strong",[t._v("解决进程同步问题的多个工具")])])]),t._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("进程可以并发或并行执行")]),t._v("，可能问题："),a("strong",[t._v("两个进程并发操作变量counter")])]),t._v(" "),a("li",[t._v("本章大部分讨论的是，协作进程如何进行==进程同步和进程协作==")])]),t._v(" "),a("h2",{attrs:{id:"临界区问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#临界区问题"}},[t._v("#")]),t._v(" 临界区问题")]),t._v(" "),a("p",[t._v("==临界区==：每个进程有一段代码（即==公共的==）")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("一个进程在临界区执行，其他进程不允许在临界区执行")])])]),t._v(" "),a("p",[t._v("设计一个协议：")]),t._v(" "),a("p",[a("img",{attrs:{src:_(788),alt:"image-20211001171303661"}})]),t._v(" "),a("p",[t._v("临界区的解决方案满足3个要求：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("互斥")]),t._v("：一个进程在临界区执行，其他不能在临界区执行")]),t._v(" "),a("li",[a("strong",[t._v("进步")]),t._v("：如果没有进程在临界区执行，那么==想加入临界区的进程一定不在剩余区==")]),t._v(" "),a("li",[a("strong",[t._v("有限等待")]),t._v("：==等待临界区的进程数量有限==")])]),t._v(" "),a("p",[a("strong",[t._v("处理操作系统临界区问题")]),t._v("：==抢占式内核和非抢占式内核==")]),t._v(" "),a("h2",{attrs:{id:"硬件同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#硬件同步"}},[t._v("#")]),t._v(" 硬件同步")]),t._v(" "),a("ul",[a("li",[t._v("基于加锁为前提，通过"),a("font",{attrs:{color:"red"}},[t._v("锁来保护临界区")]),t._v("，通过"),a("font",{attrs:{color:"red"}},[t._v("硬件指令来解决临界区问题")])],1)]),t._v(" "),a("h2",{attrs:{id:"互斥锁-自旋锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥锁-自旋锁"}},[t._v("#")]),t._v(" 互斥锁（自旋锁）")]),t._v(" "),a("p",[t._v("软件解决方法：==使用互斥锁，防止竞争条件==")]),t._v(" "),a("ul",[a("li",[t._v("进入临界区"),a("strong",[t._v("得到")]),t._v("锁，函数==acquire==（）")]),t._v(" "),a("li",[t._v("退出"),a("strong",[t._v("释放")]),t._v("锁，函数==release==（）")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(789),alt:"image-20211001175605773"}})]),t._v(" "),a("ul",[a("li",[t._v("busy wait（忙等待）：==其他进程在进入临界区是不断循环判断，所以也叫自旋锁==")])]),t._v(" "),a("blockquote",[a("p",[t._v("缺点：浪费CPU周期，不断循环while，优点：没有切换上下文，即其他进程和在临界区的进程没切换")])]),t._v(" "),a("h2",{attrs:{id:"信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),a("ul",[a("li",[t._v("信号量是一个==整型变量==")]),t._v(" "),a("li",[t._v("==wait()和signal()==来访问")]),t._v(" "),a("li",[t._v("对应P原语（测试）和V原语（增加）")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(790),alt:"image-20211001194008665"}})]),t._v(" "),a("ul",[a("li",[a("font",{attrs:{color:"red"}},[t._v("当一个进程修改信号量时，其他进程不可修改，测试和修改也不能被中断")])],1)]),t._v(" "),a("h3",{attrs:{id:"信号量的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号量的使用"}},[t._v("#")]),t._v(" 信号量的使用")]),t._v(" "),a("p",[a("strong",[t._v("计数信号量和二进制信号量（类似互斥锁）")])]),t._v(" "),a("ul",[a("li",[t._v("控制访问具有多个实例的某种资源，==信号量的初值为可用资源数量==")]),t._v(" "),a("li",[t._v("使用资源：执行==wait==（）")]),t._v(" "),a("li",[t._v("释放资源：执行==signal==（）")]),t._v(" "),a("li",[t._v("信号量的计数为0，其他想使用资源的进程将会阻塞")])]),t._v(" "),a("h3",{attrs:{id:"死锁与饥饿"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁与饥饿"}},[t._v("#")]),t._v(" 死锁与饥饿")]),t._v(" "),a("p",[t._v("死锁：==两个或多个进程无限等待一个事件==，而该事件只能由==这些等待进程之一来产生==")]),t._v(" "),a("ul",[a("li",[t._v("假设S和Q初始值为1，两个进程经过第一次wait，计数都为0，一直在那等待")]),t._v(" "),a("li",[t._v("与死锁相关的问题："),a("font",{attrs:{color:"red"}},[t._v("无限阻塞或饥饿")])],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(791),alt:"image-20211001195444270"}})]),t._v(" "),a("h3",{attrs:{id:"优先级的反转"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优先级的反转"}},[t._v("#")]),t._v(" 优先级的反转")]),t._v(" "),a("p",[t._v("进程需要资源R，而R正在被进程L访问")]),t._v(" "),a("ul",[a("li",[t._v("优先级顺序：L<M<H")]),t._v(" "),a("li",[t._v("如果不反转，进程H等待L使用完的资源（加锁了，要等待），而此时进程M运行，==抢占进程L（而M不需要资源R，所以锁对它没影响）==，影响了H等待")]),t._v(" "),a("li",[t._v("==反转（优先级继承协议）：进程L暂时由H的优先级，而M抢占不了==")])]),t._v(" "),a("h2",{attrs:{id:"经典同步问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#经典同步问题"}},[t._v("#")]),t._v(" 经典同步问题")]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("使用信号量解决同步问题")]),t._v("：")],1),t._v(" "),a("ul",[a("li",[t._v("有界缓存问题")]),t._v(" "),a("li",[t._v("读写问题（写的时候要信号量，防止多个进程同时写）")]),t._v(" "),a("li",[t._v("哲学家就餐问题")])]),t._v(" "),a("h3",{attrs:{id:"有界缓冲问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有界缓冲问题"}},[t._v("#")]),t._v(" 有界缓冲问题")]),t._v(" "),a("p",[t._v("生产者和消费者共享以下数据：")]),t._v(" "),a("p",[a("img",{attrs:{src:_(792),alt:"image-20211001201942263"}})]),t._v(" "),a("ul",[a("li",[t._v("信号量mutex：初始化为1")]),t._v(" "),a("li",[t._v("empty（生产后-1，可消费+1）：没有生产，为空（n)")]),t._v(" "),a("li",[t._v("full（消费后-1，可生产+1）：生产满了，等待消费者消费(0，还没生产，所以初始消费为0)")])]),t._v(" "),a("p",[t._v("==wait执行后-1，而signal执行后+1==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(793),alt:"image-20211001202221971"}}),a("img",{attrs:{src:_(794),alt:"image-20211001202242286"}})]),t._v(" "),a("h3",{attrs:{id:"哲学家就餐问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哲学家就餐问题"}},[t._v("#")]),t._v(" 哲学家就餐问题")]),t._v(" "),a("p",[t._v("哲学家只做两件事：思考和吃饭（两个叉子才能吃）")]),t._v(" "),a("ul",[a("li",[t._v("发生死锁，所有哲学家饿死")]),t._v(" "),a("li",[t._v("每个叉子用一个信号量（1）表示，即每个人那右手边的叉子，拿完信号量为0")]),t._v(" "),a("li",[t._v("==取余（很秒***）：即拿到本身，即2号拿2号叉子，3拿3，4拿0==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(795),alt:"image-20211001204306195"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("死锁补救：")]),t._v(" "),a("ol",[a("li",[t._v("4个哲学家5个叉子")]),t._v(" "),a("li",[t._v("==有一个哲学家==当"),a("strong",[t._v("两个叉子都可用时才拿起他们")]),t._v("（相当于奉献自己的一个叉子）")]),t._v(" "),a("li",[t._v("单号哲学家先拿起左边的叉子，接着拿右边，而双号先拿右边再拿左边")])])]),t._v(" "),a("li",[a("p",[t._v("没有一个饿死，但可能有人会饥饿")])])]),t._v(" "),a("h1",{attrs:{id:"第七章-死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第七章-死锁"}},[t._v("#")]),t._v(" 第七章 死锁")]),t._v(" "),a("blockquote",[a("p",[t._v("多道程序中，多个进程竞争有限资源，如果申请的资源被其他等待进程占有（即打印机，键盘，一开始我占打印机，你占键盘，第二次我想占键盘，而你占打印机，因为"),a("strong",[t._v("同时需要对方的资源")]),t._v("，所以一直等待），称为死锁")])]),t._v(" "),a("p",[a("strong",[t._v("本章目标")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("==解释死锁==，即一组并发进程不能完成执行任务")]),t._v(" "),a("li",[t._v("提出一些方法，==避免死锁==")])]),t._v(" "),a("h2",{attrs:{id:"死锁特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁特征"}},[t._v("#")]),t._v(" 死锁特征")]),t._v(" "),a("ul",[a("li",[t._v("进程永远不能完成")])]),t._v(" "),a("h3",{attrs:{id:"死锁的必要条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁的必要条件"}},[t._v("#")]),t._v(" 死锁的必要条件")]),t._v(" "),a("p",[t._v("四个条件（==死锁四个条件都成立，而四个条件成立不一定发生死锁==）：")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("互斥")]),t._v("：至少有一个资源处于非共享模式，即一个进程使用了，另一个进程等待")]),t._v(" "),a("li",[t._v("==占有并等待==：占有一个资源，等待另一个资源")]),t._v(" "),a("li",[a("strong",[t._v("非抢占")]),t._v("：资源不能被抢占")]),t._v(" "),a("li",[a("strong",[t._v("循环等待")]),t._v("（意味着==占有并等待==）：A-B-C-A，即A等待资源被B占，B等待资源被C占，而C等待的资源被A占")])]),t._v(" "),a("h2",{attrs:{id:"死锁预防"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁预防"}},[t._v("#")]),t._v(" 死锁预防")]),t._v(" "),a("p",[t._v("4个条件中一个不成立即可")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("互斥：只读就行")])]),t._v(" "),a("li",[a("p",[t._v("占有并等待：")]),t._v(" "),a("ol",[a("li",[t._v("==每个进程再执行前申请获得所有资源==：即申请资源的系统调用在所有其他系统调用之前进行")]),t._v(" "),a("li",[t._v("在没有资源时才可申请资源：==它申请其他资源时已释放自己占有的==")]),t._v(" "),a("li",[t._v("缺点：第一个方法：资源利用率低；第二个方法：发生饥饿")])])]),t._v(" "),a("li",[a("p",[t._v("非抢占：通常==在CPU寄存器和内存使用==，即可以保存和恢复，==不适用互斥锁和信号量==")]),t._v(" "),a("blockquote",[a("p",[t._v("一个进程申请的资源不能立即分配，那么它现在分配的资源都可被抢占，最后"),a("strong",[t._v("它原有的资源和申请的资源空闲时，它才重新执行")])])])]),t._v(" "),a("li",[a("p",[t._v("循环等待：对所有资源排序，"),a("font",{attrs:{color:"red"}},[t._v("每个进程按递增顺序来申请资源")]),t._v("，保证进程所需资源被开始的进程占有即可")],1)])]),t._v(" "),a("h2",{attrs:{id:"死锁恢复"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁恢复"}},[t._v("#")]),t._v(" 死锁恢复")]),t._v(" "),a("p",[t._v("检测到死锁发生：")]),t._v(" "),a("ul",[a("li",[t._v("通知操作员处理死锁（操作硬件不可取）")]),t._v(" "),a("li",[t._v("让系统从死锁自动恢复（recover）\n"),a("ol",[a("li",[t._v("中止进程（暴力不可取）")]),t._v(" "),a("li",[t._v("==允许抢占资源==")])])])]),t._v(" "),a("h1",{attrs:{id:"第八章-内存管理策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第八章-内存管理策略"}},[t._v("#")]),t._v(" 第八章 内存管理策略")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("计算机系统主要执行程序，执行程序访问数据部分在内存里，为了提高CPU利用率和响应用户速度，"),a("strong",[t._v("内存必须保留多个进程")])]),t._v(" "),a("li",[t._v("内存管理方法：分页和分段")]),t._v(" "),a("li",[t._v("取决因素：系统的硬件设计")])])]),t._v(" "),a("p",[a("strong",[t._v("本章目标")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("描述"),a("font",{attrs:{color:"red"}},[t._v("内存硬件的各种组织方法")])],1),t._v(" "),a("li",[t._v("探讨进程"),a("font",{attrs:{color:"red"}},[t._v("内存分配的各种技术")])],1),t._v(" "),a("li",[t._v("讨论现代计算机系统的"),a("font",{attrs:{color:"red"}},[t._v("分页如何工作")])],1)]),t._v(" "),a("h2",{attrs:{id:"背景-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景-2"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("ul",[a("li",[t._v("内存：很大的字节数组组成，每个字节有自己的地址（即内存地址）")])]),t._v(" "),a("h3",{attrs:{id:"基本硬件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本硬件"}},[t._v("#")]),t._v(" 基本硬件")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("确保进程有==单独的内存空间==")])]),t._v(" "),a("li",[a("p",[t._v("确定进程可以==访问的合法地址范围==")])]),t._v(" "),a("li",[a("p",[t._v("两个寄存器："),a("font",{attrs:{color:"red"}},[t._v("基地址和界限地址")])],1),t._v(" "),a("ol",[a("li",[t._v("基地址：合法的"),a("strong",[t._v("最小内存地址")])]),t._v(" "),a("li",[t._v("界限地址：合法范围地址的"),a("strong",[t._v("范围大小")])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(796),alt:"image-20211002105525613"}})])])]),t._v(" "),a("blockquote",[a("p",[t._v("只有操作系统可以操作基地址和界限地址，而不允许用户程序修改（即木马）")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(797),alt:"image-20211002105603116"}})]),t._v(" "),a("h3",{attrs:{id:"地址绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#地址绑定"}},[t._v("#")]),t._v(" 地址绑定")]),t._v(" "),a("ul",[a("li",[t._v("程序存放在磁盘中，执行时调入内存放在进程中")]),t._v(" "),a("li",[t._v("输入队列：磁盘等待进入内存（即作业池，等待分配内存）")])]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("程序是存放在磁盘中，运行时得放在内存中成为进程")])])]),t._v(" "),a("hr"),t._v(" "),a("ul",[a("li",[t._v("源程序地址：用符号表示")]),t._v(" "),a("li",[t._v("编译器：符号地址----可重定位地址")]),t._v(" "),a("li",[t._v("链接器：可重定位地址-----绝对地址")])]),t._v(" "),a("p",[t._v("知道内存地址方法：")]),t._v(" "),a("ol",[a("li",[t._v("编译时：==编译时知道进程内存地址，生成绝对代码==，将来地址发送变化，"),a("font",{attrs:{color:"red"}},[t._v("需重新编译代码")])],1),t._v(" "),a("li",[t._v("加载时：编译不知道地址，加载时知道，地址变化时需重新加载")]),t._v(" "),a("li",[t._v("==执行时（常用）==：一个内存到另一个内存，执行时知道地址")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(798),alt:"image-20211002111618538"}})]),t._v(" "),a("h3",{attrs:{id:"逻辑地址空间与物理地址空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逻辑地址空间与物理地址空间"}},[t._v("#")]),t._v(" 逻辑地址空间与物理地址空间")]),t._v(" "),a("p",[t._v("CPU地址：逻辑地址")]),t._v(" "),a("p",[t._v("内存地址：物理地址")]),t._v(" "),a("ul",[a("li",[a("font",{attrs:{color:"red"}},[t._v("编译和加载生成相同的逻辑地址和物理地址")])],1),t._v(" "),a("li",[t._v("执行生成不相同\n"),a("ol",[a("li",[a("font",{attrs:{color:"red"}},[t._v("逻辑地址（虚拟地址）：所有逻辑地址的集合为逻辑地址空间")])],1),t._v(" "),a("li",[t._v("逻辑地址对应的物理地址集合为物理地址空间")])])])]),t._v(" "),a("blockquote",[a("p",[t._v("逻辑地址到物理地址是由**内存管理单元MMU（Memory-Management Unit）**的硬件设备完成的，"),a("strong",[t._v("使用基地址寄存器（也叫重定位寄存器）")])])]),t._v(" "),a("ul",[a("li",[t._v("用户程序不会看到真实的物理地址，即访问0对应物理地址是14000")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(799),alt:"image-20211002114426185"}})]),t._v(" "),a("h3",{attrs:{id:"动态加载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态加载"}},[t._v("#")]),t._v(" 动态加载")]),t._v(" "),a("blockquote",[a("p",[t._v("更好的内存空间利用率，因为程序数据要经过内存，所以内存有限")])]),t._v(" "),a("ul",[a("li",[t._v("优点：只有一个程序被需要时，它才会被加载，节省内存")])]),t._v(" "),a("h2",{attrs:{id:"交换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#交换"}},[t._v("#")]),t._v(" 交换")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("进程可以暂时交换到磁盘")]),t._v("，让总的物理地址空间超过真实空间，增加了相同的多道程序程度")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(800),alt:"image-20211002121635952"}})]),t._v(" "),a("h3",{attrs:{id:"标准交换-不用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标准交换-不用"}},[t._v("#")]),t._v(" 标准交换（不用）")]),t._v(" "),a("ul",[a("li",[t._v("当CPU调度器执行一个进程时，调用分派器，查询进程是否在内存中，不在则==换出（swap out）==内存的一个进程，并==换入（swap in）==所需进程")]),t._v(" "),a("li",[t._v("缺点：耗时")]),t._v(" "),a("li",[t._v("==变种（通常与虚拟内存工作）：==\n"),a("ol",[a("li",[a("font",{attrs:{color:"red"}},[t._v("有多余内存空闲，开始交换")])],1),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("交换进程的部分")])],1)])])]),t._v(" "),a("h3",{attrs:{id:"移动系统的交换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动系统的交换"}},[t._v("#")]),t._v(" 移动系统的交换")]),t._v(" "),a("ul",[a("li",[t._v("移动不支持任何的交换，采用闪存，不用磁盘")]),t._v(" "),a("li",[t._v("苹果iOS："),a("font",{attrs:{color:"red"}},[t._v("要求重新自愿放弃分配内存，只读可删除")])],1),t._v(" "),a("li",[t._v("Android："),a("font",{attrs:{color:"red"}},[t._v("终止程序，写到闪存")])],1)]),t._v(" "),a("blockquote",[a("p",[t._v("注意：iOS和Android支持分页，有内存管理能力")])]),t._v(" "),a("h2",{attrs:{id:"连续内存分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连续内存分配"}},[t._v("#")]),t._v(" 连续内存分配")]),t._v(" "),a("blockquote",[a("p",[t._v("内存分为两个区域：一个放操作系统，一个放用户进程")])]),t._v(" "),a("h3",{attrs:{id:"内存保护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存保护"}},[t._v("#")]),t._v(" 内存保护")]),t._v(" "),a("ul",[a("li",[t._v("防止进程访问其他内存")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(801),alt:"image-20211002171251122"}})]),t._v(" "),a("h3",{attrs:{id:"内存分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[t._v("#")]),t._v(" 内存分配")]),t._v(" "),a("blockquote",[a("p",[t._v("固定分区推广（MVT），用于批处理环境")])]),t._v(" "),a("ul",[a("li",[t._v("可变分区：操作系统有一个表，记录哪些内存可用和哪些已用")]),t._v(" "),a("li",[t._v("内存有一个集合，包含各种大小的==孔（即内存的子集）==\n"),a("ol",[a("li",[a("font",{attrs:{color:"red"}},[t._v("首次")]),t._v("适应（快）：一旦找到比它大的内存（孔）则停")],1),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("最优")]),t._v("适应（好）：分配最小的孔，要排序")],1),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("最差")]),t._v("适应（差）：分配最大的孔，排序拿最大的（==和首次区别在于首次是找到比它大就行，不一定是最大的==）")],1)])])]),t._v(" "),a("h3",{attrs:{id:"内存碎片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存碎片"}},[t._v("#")]),t._v(" 内存碎片")]),t._v(" "),a("blockquote",[a("p",[t._v("即分配的孔没用完，孔地址之间不连续，"),a("strong",[t._v("导致孔的大小虽然满足，但是不可用")])])]),t._v(" "),a("p",[t._v("解决方案：")]),t._v(" "),a("ul",[a("li",[t._v("==允许逻辑地址不连续==")]),t._v(" "),a("li",[t._v("==两种互补技术：分段和分页==，两个技术组合")])]),t._v(" "),a("h2",{attrs:{id:"分段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分段"}},[t._v("#")]),t._v(" 分段")]),t._v(" "),a("blockquote",[a("p",[t._v("内存管理方案")])]),t._v(" "),a("p",[a("font",{attrs:{color:"red"}},[t._v("逻辑地址由有序对组成《段号，偏移》")])],1),t._v(" "),a("ul",[a("li",[t._v("==段号：相当于索引==")]),t._v(" "),a("li",[t._v("==偏移：即界限地址==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(802),alt:"image-20211002175500028"}})]),t._v(" "),a("h3",{attrs:{id:"基本方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本方法"}},[t._v("#")]),t._v(" 基本方法")]),t._v(" "),a("ul",[a("li",[t._v("程序会装入不同段，每个段都有段号")])]),t._v(" "),a("h3",{attrs:{id:"分段硬件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分段硬件"}},[t._v("#")]),t._v(" 分段硬件")]),t._v(" "),a("blockquote",[a("p",[t._v("逻辑虽然是二维数组，而实际物理内存仍然是一维，所以定义一个段表")]),t._v(" "),a("p",[t._v("==段表有段基地址和段界限==，"),a("font",{attrs:{color:"red"}},[t._v("索引到段表，然后两个界限判断，最后偏移加上基址成为最终物理地址")])],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(803),alt:"image-20211002180416674"}})]),t._v(" "),a("h2",{attrs:{id:"分页-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分页-重点"}},[t._v("#")]),t._v(" 分页（重点）")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("分页避免了外部碎片，而分段不行")]),t._v("；被大多数操作系统采用")]),t._v(" "),a("ul",[a("li",[t._v("内部碎片：即分配给它的内存没用完")]),t._v(" "),a("li",[t._v("外部碎片：帧和页大小相同，解决了碎片")])])]),t._v(" "),a("h3",{attrs:{id:"基本方法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本方法-2"}},[t._v("#")]),t._v(" 基本方法")]),t._v(" "),a("p",[t._v("分段大小不固定，分页大小固定")]),t._v(" "),a("ul",[a("li",[t._v("==物理内存：帧或页帧==")]),t._v(" "),a("li",[t._v("==逻辑内存：页或页面==")]),t._v(" "),a("li",[a("font",{attrs:{color:"red"}},[t._v("页码")]),t._v("（对应页表的索引）和页偏移")],1)]),t._v(" "),a("p",[a("img",{attrs:{src:_(804),alt:"image-20211002191123931"}})]),t._v(" "),a("p",[a("img",{attrs:{src:_(805),alt:"image-20211002191611822"}})]),t._v(" "),a("p",[t._v("==页大小(2的幂)==2 ^ n")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("例：n=2,m=4,==4字节对应32字节内存，页大小2的二次方=4；==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(806),alt:"image-20211002192631317"}})])]),t._v(" "),a("li",[a("p",[t._v("==n页对应n帧，分配完更新==")])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(807),alt:"image-20211002192952272"}})]),t._v(" "),a("h3",{attrs:{id:"硬件支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#硬件支持"}},[t._v("#")]),t._v(" 硬件支持")]),t._v(" "),a("blockquote",[a("p",[t._v("比之前多一个TLB（转换表缓冲区 Translation Look-aside Buffer），搜索速度快")])]),t._v(" "),a("ul",[a("li",[t._v("如果不在则称为==TLB未命中==，==此时需要访问页表==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(808),alt:"image-20211002194510268"}})]),t._v(" "),a("h3",{attrs:{id:"共享页"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#共享页"}},[t._v("#")]),t._v(" 共享页")]),t._v(" "),a("blockquote",[a("p",[t._v("共享公共代码，但数据不行")])]),t._v(" "),a("ul",[a("li",[t._v("代码是==可重入代码或纯代码，执行期间不可修改==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(809),alt:"image-20211002194943763"}})]),t._v(" "),a("h2",{attrs:{id:"页表结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页表结构"}},[t._v("#")]),t._v(" 页表结构")]),t._v(" "),a("blockquote",[a("p",[t._v("分层分页、哈希页表、倒置页表")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("分层分页")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("哈希页表")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("倒置页表")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("页表太大，将==页表划分==")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("虚拟页码，映射帧码，下一个元素的指针")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("整个系统==只有一个页表==，缺点：==查找页表时间长，不能共享内存==")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:_(810),alt:"image-20211002201819579"}})]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:_(811),alt:"image-20211002202226147"}})]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:_(812),alt:"image-20211002202513602"}})])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("p1外部页表索引，p2内部页表的偏移，由于外到内，叫==向前映射页表==")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("虚拟地址：《进程pid，页码，偏移》")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("img",{attrs:{src:_(813),alt:"image-20211002202009729"}})]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("倒置页表：《进程pid，页码》")])])])]),t._v(" "),a("h1",{attrs:{id:"第九章-虚拟内存管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第九章-虚拟内存管理"}},[t._v("#")]),t._v(" 第九章 虚拟内存管理")]),t._v(" "),a("blockquote",[a("p",[t._v("之前说是所有进程执行前应在内存中")])]),t._v(" "),a("ul",[a("li",[t._v("虚拟内存技术允许进程不必处于内存，"),a("strong",[t._v("实现逻辑内存和物理内存分离")])])]),t._v(" "),a("p",[a("strong",[t._v("本章目标：")])]),t._v(" "),a("ul",[a("li",[t._v("讨论虚拟内存系统的优点")]),t._v(" "),a("li",[t._v("解释"),a("font",{attrs:{color:"red"}},[t._v("请求调页、页置换算法和页帧分配")])],1),t._v(" "),a("li",[t._v("讨论"),a("strong",[t._v("工作集模型")]),t._v("原理")]),t._v(" "),a("li",[t._v("讨论"),a("strong",[t._v("共享内存和内存映射文件之间")]),t._v("的关系")])]),t._v(" "),a("h2",{attrs:{id:"背景-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景-3"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("blockquote",[a("p",[t._v("一些报异常代码很少用到，所以没必要放到内存")])]),t._v(" "),a("ul",[a("li",[t._v("分段==执行部分==处于内存的程序优点：\n"),a("ol",[a("li",[t._v("程序不受内存限制")]),t._v(" "),a("li",[t._v("增加CPU利用率和吞吐量")]),t._v(" "),a("li",[t._v("时间没变化（还是用到IO设备）")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(814),alt:"image-20211002211121694"}})]),t._v(" "),a("p",[t._v("==进程的虚拟地址空间==")]),t._v(" "),a("p",[a("img",{attrs:{src:_(815),alt:"image-20211002211543016"}})]),t._v(" "),a("h2",{attrs:{id:"请求调页-换入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求调页-换入"}},[t._v("#")]),t._v(" 请求调页（换入）")]),t._v(" "),a("blockquote",[a("p",[t._v("用于虚拟内存系统，即"),a("font",{attrs:{color:"red"}},[t._v("用到那个就从磁盘取到内存（惰性交换器）")]),t._v("，类似交换")],1)]),t._v(" "),a("ul",[a("li",[t._v("使用==调页程序==：涉及进程的页面")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(816),alt:"image-20211003173154934"}})]),t._v(" "),a("h3",{attrs:{id:"基本概念-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基本概念-2"}},[t._v("#")]),t._v(" 基本概念")]),t._v(" "),a("p",[t._v("硬件支持："),a("font",{attrs:{color:"red"}},[t._v("区分内存的页面和磁盘的页面")])],1),t._v(" "),a("ul",[a("li",[t._v("使用有效(valid)-无效(invalid)位方案")]),t._v(" "),a("li",[t._v("无效：可能是真不存在，或者它存在磁盘中")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(817),alt:"image-20211003173419937"}})]),t._v(" "),a("ul",[a("li",[t._v("对"),a("font",{attrs:{color:"red"}},[t._v("标记无效的页面访问会产生缺页错误")])],1),t._v(" "),a("li",[t._v("解决方法：\n"),a("ol",[a("li",[t._v("检查页表")]),t._v(" "),a("li",[t._v("如果引用无效，终止进程==，引用有效但是未调入页面，就调入页面==")]),t._v(" "),a("li",[t._v("找到空闲帧")]),t._v(" "),a("li",[t._v("从磁盘读取到空闲的帧里")]),t._v(" "),a("li",[t._v("==修改进程页表，标识页处于内存中==")]),t._v(" "),a("li",[t._v("==重新启动被陷阱中断的指令==")])])])]),t._v(" "),a("p",[a("img",{attrs:{src:_(818),alt:"image-20211003174925826"}})]),t._v(" "),a("ul",[a("li",[t._v("纯请求调页：需要时才将页面调入内存")]),t._v(" "),a("li",[t._v("一个指令可能引起多个缺页错误，导致不可接受的系统性能（几乎不可能）\n"),a("ul",[a("li",[t._v("==程序具有局部引用，使得请求调页合理==")])])])]),t._v(" "),a("h2",{attrs:{id:"页面置换-换出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面置换-换出"}},[t._v("#")]),t._v(" 页面置换（换出）")]),t._v(" "),a("blockquote",[a("p",[t._v("内存已满，想在换入时，得换出一些（页面置换）")])]),t._v(" "),a("h3",{attrs:{id:"fifo页面置换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fifo页面置换"}},[t._v("#")]),t._v(" FIFO页面置换")]),t._v(" "),a("blockquote",[a("p",[t._v("最简单的算法：先进先出，选择最旧的页面换出")])]),t._v(" "),a("h3",{attrs:{id:"最优页面置换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最优页面置换"}},[t._v("#")]),t._v(" 最优页面置换")]),t._v(" "),a("blockquote",[a("p",[t._v("置换最长时间没使用的页面")])]),t._v(" "),a("ul",[a("li",[t._v("和FIFO有区别：==它是长时间没用，而FIFO是满了==，它可能被换出之前使用了，但"),a("font",{attrs:{color:"red"}},[t._v("由于已满必须得换出")])],1)]),t._v(" "),a("h3",{attrs:{id:"lru页面置换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lru页面置换"}},[t._v("#")]),t._v(" LRU页面置换")]),t._v(" "),a("p",[t._v("Least-Recent-Used：最近最少使用，==将每个页面和上次使用的时间关联起来，计算时间差==")]),t._v(" "),a("h3",{attrs:{id:"基于计数的页面置换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于计数的页面置换"}},[t._v("#")]),t._v(" 基于计数的页面置换")]),t._v(" "),a("blockquote",[a("p",[t._v("计数器")])]),t._v(" "),a("ul",[a("li",[t._v("最不经常使用（Least Frequently Used ，LFU）：==要求置换最小计数的页面==，具有最大计数的，如果长时间不用会--")]),t._v(" "),a("li",[t._v("最经常使用（Most Frequently Used，MFU）：基于以下论点：最小计数的页面可能是刚换入的，==看使用频率==")])]),t._v(" "),a("h2",{attrs:{id:"帧分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#帧分配"}},[t._v("#")]),t._v(" 帧分配")]),t._v(" "),a("blockquote",[a("p",[t._v("每个进程分配多少帧")])]),t._v(" "),a("h3",{attrs:{id:"帧的最小数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#帧的最小数"}},[t._v("#")]),t._v(" 帧的最小数")]),t._v(" "),a("blockquote",[a("p",[t._v("即分配接近和进程所需的帧")])]),t._v(" "),a("h3",{attrs:{id:"分配算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分配算法"}},[t._v("#")]),t._v(" 分配算法")]),t._v(" "),a("ul",[a("li",[t._v("平均分配：每个进程分配相同数量的帧")]),t._v(" "),a("li",[t._v("按比例分配：进程占用内存越大，分配帧越多，==它不确保每个进程所分配的帧接近其所需的==")])]),t._v(" "),a("h3",{attrs:{id:"全局分配与局部分配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局分配与局部分配"}},[t._v("#")]),t._v(" 全局分配与局部分配")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("分配帧的一个重要因素是页面置换")])])]),t._v(" "),a("ul",[a("li",[t._v("页面置换算法\n"),a("ul",[a("li",[t._v("==全局置换：一个进程可以从另一个进程获取帧==")]),t._v(" "),a("li",[t._v("局部置换：进程之间不可交互")])])])]),t._v(" "),a("h2",{attrs:{id:"系统抖动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统抖动"}},[t._v("#")]),t._v(" 系统抖动")]),t._v(" "),a("blockquote",[a("p",[t._v("抖动：页面调度活动，一个进行调页时间多于它的执行时间")])]),t._v(" "),a("h3",{attrs:{id:"系统抖动的原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统抖动的原因"}},[t._v("#")]),t._v(" 系统抖动的原因")]),t._v(" "),a("ul",[a("li",[t._v("产生缺页错误，其他所有页面都在使用，==你抢它的页面，而它又去抢别的，导致很大进程等待调页设备（IO设备很耗时），CPU利用率降低==")])]),t._v(" "),a("p",[t._v("解决抖动问题：")]),t._v(" "),a("ul",[a("li",[t._v("==通过局部置换算法，即不影响其他的进程==")]),t._v(" "),a("li",[t._v("缺页错误频率：设置缺页错误率的上下限\n"),a("ul",[a("li",[t._v("错误率过高：增加进程的帧数")]),t._v(" "),a("li",[t._v("过低：减少帧数")])])])]),t._v(" "),a("h3",{attrs:{id:"内存映射文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存映射文件"}},[t._v("#")]),t._v(" 内存映射文件")]),t._v(" "),a("blockquote",[a("p",[t._v("将文件I/O作为常规内存访问，允许==部分虚拟内存与文件进行逻辑关联==")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(819),alt:"image-20211003194942762"}})])])}),[],!1,null,null,null);v.default=r.exports}}]);